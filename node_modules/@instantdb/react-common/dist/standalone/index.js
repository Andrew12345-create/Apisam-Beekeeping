import Sr, { useRef as ze, useCallback as de, useSyncExternalStore as Mt, useEffect as ge, useMemo as Rt, useState as Or } from "react";
var $t = { exports: {} }, $e = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Un;
function Ni() {
  if (Un) return $e;
  Un = 1;
  var t = Sr, e = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(u, a, d) {
    var c, f = {}, l = null, p = null;
    d !== void 0 && (l = "" + d), a.key !== void 0 && (l = "" + a.key), a.ref !== void 0 && (p = a.ref);
    for (c in a) r.call(a, c) && !s.hasOwnProperty(c) && (f[c] = a[c]);
    if (u && u.defaultProps) for (c in a = u.defaultProps, a) f[c] === void 0 && (f[c] = a[c]);
    return { $$typeof: e, type: u, key: l, ref: p, props: f, _owner: i.current };
  }
  return $e.Fragment = n, $e.jsx = o, $e.jsxs = o, $e;
}
var xe = {}, Ln;
function Ki() {
  if (Ln) return xe;
  Ln = 1;
  var t = {};
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return t.NODE_ENV !== "production" && function() {
    var e = Sr, n = Symbol.for("react.element"), r = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), u = Symbol.for("react.provider"), a = Symbol.for("react.context"), d = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), l = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), b = Symbol.iterator, g = "@@iterator";
    function m(h) {
      if (h === null || typeof h != "object")
        return null;
      var _ = b && h[b] || h[g];
      return typeof _ == "function" ? _ : null;
    }
    var T = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function v(h) {
      {
        for (var _ = arguments.length, w = new Array(_ > 1 ? _ - 1 : 0), O = 1; O < _; O++)
          w[O - 1] = arguments[O];
        k("error", h, w);
      }
    }
    function k(h, _, w) {
      {
        var O = T.ReactDebugCurrentFrame, C = O.getStackAddendum();
        C !== "" && (_ += "%s", w = w.concat([C]));
        var P = w.map(function(j) {
          return String(j);
        });
        P.unshift("Warning: " + _), Function.prototype.apply.call(console[h], console, P);
      }
    }
    var S = !1, I = !1, R = !1, q = !1, Ie = !1, Qe;
    Qe = Symbol.for("react.module.reference");
    function _t(h) {
      return !!(typeof h == "string" || typeof h == "function" || h === i || h === o || Ie || h === s || h === c || h === f || q || h === y || S || I || R || typeof h == "object" && h !== null && (h.$$typeof === p || h.$$typeof === l || h.$$typeof === u || h.$$typeof === a || h.$$typeof === d || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      h.$$typeof === Qe || h.getModuleId !== void 0));
    }
    function gt(h, _, w) {
      var O = h.displayName;
      if (O)
        return O;
      var C = _.displayName || _.name || "";
      return C !== "" ? w + "(" + C + ")" : w;
    }
    function He(h) {
      return h.displayName || "Context";
    }
    function ne(h) {
      if (h == null)
        return null;
      if (typeof h.tag == "number" && v("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof h == "function")
        return h.displayName || h.name || null;
      if (typeof h == "string")
        return h;
      switch (h) {
        case i:
          return "Fragment";
        case r:
          return "Portal";
        case o:
          return "Profiler";
        case s:
          return "StrictMode";
        case c:
          return "Suspense";
        case f:
          return "SuspenseList";
      }
      if (typeof h == "object")
        switch (h.$$typeof) {
          case a:
            var _ = h;
            return He(_) + ".Consumer";
          case u:
            var w = h;
            return He(w._context) + ".Provider";
          case d:
            return gt(h, h.render, "ForwardRef");
          case l:
            var O = h.displayName || null;
            return O !== null ? O : ne(h.type) || "Memo";
          case p: {
            var C = h, P = C._payload, j = C._init;
            try {
              return ne(j(P));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var le = Object.assign, Me = 0, pn, yn, bn, _n, gn, Tn, mn;
    function wn() {
    }
    wn.__reactDisabledLog = !0;
    function hi() {
      {
        if (Me === 0) {
          pn = console.log, yn = console.info, bn = console.warn, _n = console.error, gn = console.group, Tn = console.groupCollapsed, mn = console.groupEnd;
          var h = {
            configurable: !0,
            enumerable: !0,
            value: wn,
            writable: !0
          };
          Object.defineProperties(console, {
            info: h,
            log: h,
            warn: h,
            error: h,
            group: h,
            groupCollapsed: h,
            groupEnd: h
          });
        }
        Me++;
      }
    }
    function pi() {
      {
        if (Me--, Me === 0) {
          var h = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: le({}, h, {
              value: pn
            }),
            info: le({}, h, {
              value: yn
            }),
            warn: le({}, h, {
              value: bn
            }),
            error: le({}, h, {
              value: _n
            }),
            group: le({}, h, {
              value: gn
            }),
            groupCollapsed: le({}, h, {
              value: Tn
            }),
            groupEnd: le({}, h, {
              value: mn
            })
          });
        }
        Me < 0 && v("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Tt = T.ReactCurrentDispatcher, mt;
    function Ye(h, _, w) {
      {
        if (mt === void 0)
          try {
            throw Error();
          } catch (C) {
            var O = C.stack.trim().match(/\n( *(at )?)/);
            mt = O && O[1] || "";
          }
        return `
` + mt + h;
      }
    }
    var wt = !1, Je;
    {
      var yi = typeof WeakMap == "function" ? WeakMap : Map;
      Je = new yi();
    }
    function vn(h, _) {
      if (!h || wt)
        return "";
      {
        var w = Je.get(h);
        if (w !== void 0)
          return w;
      }
      var O;
      wt = !0;
      var C = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var P;
      P = Tt.current, Tt.current = null, hi();
      try {
        if (_) {
          var j = function() {
            throw Error();
          };
          if (Object.defineProperty(j.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(j, []);
            } catch (W) {
              O = W;
            }
            Reflect.construct(h, [], j);
          } else {
            try {
              j.call();
            } catch (W) {
              O = W;
            }
            h.call(j.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (W) {
            O = W;
          }
          h();
        }
      } catch (W) {
        if (W && O && typeof W.stack == "string") {
          for (var E = W.stack.split(`
`), z = O.stack.split(`
`), $ = E.length - 1, D = z.length - 1; $ >= 1 && D >= 0 && E[$] !== z[D]; )
            D--;
          for (; $ >= 1 && D >= 0; $--, D--)
            if (E[$] !== z[D]) {
              if ($ !== 1 || D !== 1)
                do
                  if ($--, D--, D < 0 || E[$] !== z[D]) {
                    var J = `
` + E[$].replace(" at new ", " at ");
                    return h.displayName && J.includes("<anonymous>") && (J = J.replace("<anonymous>", h.displayName)), typeof h == "function" && Je.set(h, J), J;
                  }
                while ($ >= 1 && D >= 0);
              break;
            }
        }
      } finally {
        wt = !1, Tt.current = P, pi(), Error.prepareStackTrace = C;
      }
      var ve = h ? h.displayName || h.name : "", he = ve ? Ye(ve) : "";
      return typeof h == "function" && Je.set(h, he), he;
    }
    function bi(h, _, w) {
      return vn(h, !1);
    }
    function _i(h) {
      var _ = h.prototype;
      return !!(_ && _.isReactComponent);
    }
    function Ze(h, _, w) {
      if (h == null)
        return "";
      if (typeof h == "function")
        return vn(h, _i(h));
      if (typeof h == "string")
        return Ye(h);
      switch (h) {
        case c:
          return Ye("Suspense");
        case f:
          return Ye("SuspenseList");
      }
      if (typeof h == "object")
        switch (h.$$typeof) {
          case d:
            return bi(h.render);
          case l:
            return Ze(h.type, _, w);
          case p: {
            var O = h, C = O._payload, P = O._init;
            try {
              return Ze(P(C), _, w);
            } catch {
            }
          }
        }
      return "";
    }
    var Re = Object.prototype.hasOwnProperty, Sn = {}, On = T.ReactDebugCurrentFrame;
    function Xe(h) {
      if (h) {
        var _ = h._owner, w = Ze(h.type, h._source, _ ? _.type : null);
        On.setExtraStackFrame(w);
      } else
        On.setExtraStackFrame(null);
    }
    function gi(h, _, w, O, C) {
      {
        var P = Function.call.bind(Re);
        for (var j in h)
          if (P(h, j)) {
            var E = void 0;
            try {
              if (typeof h[j] != "function") {
                var z = Error((O || "React class") + ": " + w + " type `" + j + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof h[j] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw z.name = "Invariant Violation", z;
              }
              E = h[j](_, j, O, w, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch ($) {
              E = $;
            }
            E && !(E instanceof Error) && (Xe(C), v("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", O || "React class", w, j, typeof E), Xe(null)), E instanceof Error && !(E.message in Sn) && (Sn[E.message] = !0, Xe(C), v("Failed %s type: %s", w, E.message), Xe(null));
          }
      }
    }
    var Ti = Array.isArray;
    function vt(h) {
      return Ti(h);
    }
    function mi(h) {
      {
        var _ = typeof Symbol == "function" && Symbol.toStringTag, w = _ && h[Symbol.toStringTag] || h.constructor.name || "Object";
        return w;
      }
    }
    function wi(h) {
      try {
        return En(h), !1;
      } catch {
        return !0;
      }
    }
    function En(h) {
      return "" + h;
    }
    function An(h) {
      if (wi(h))
        return v("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", mi(h)), En(h);
    }
    var jn = T.ReactCurrentOwner, vi = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, kn, Cn;
    function Si(h) {
      if (Re.call(h, "ref")) {
        var _ = Object.getOwnPropertyDescriptor(h, "ref").get;
        if (_ && _.isReactWarning)
          return !1;
      }
      return h.ref !== void 0;
    }
    function Oi(h) {
      if (Re.call(h, "key")) {
        var _ = Object.getOwnPropertyDescriptor(h, "key").get;
        if (_ && _.isReactWarning)
          return !1;
      }
      return h.key !== void 0;
    }
    function Ei(h, _) {
      typeof h.ref == "string" && jn.current;
    }
    function Ai(h, _) {
      {
        var w = function() {
          kn || (kn = !0, v("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", _));
        };
        w.isReactWarning = !0, Object.defineProperty(h, "key", {
          get: w,
          configurable: !0
        });
      }
    }
    function ji(h, _) {
      {
        var w = function() {
          Cn || (Cn = !0, v("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", _));
        };
        w.isReactWarning = !0, Object.defineProperty(h, "ref", {
          get: w,
          configurable: !0
        });
      }
    }
    var ki = function(h, _, w, O, C, P, j) {
      var E = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: n,
        // Built-in properties that belong on the element
        type: h,
        key: _,
        ref: w,
        props: j,
        // Record the component responsible for creating this element.
        _owner: P
      };
      return E._store = {}, Object.defineProperty(E._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(E, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: O
      }), Object.defineProperty(E, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: C
      }), Object.freeze && (Object.freeze(E.props), Object.freeze(E)), E;
    };
    function Ci(h, _, w, O, C) {
      {
        var P, j = {}, E = null, z = null;
        w !== void 0 && (An(w), E = "" + w), Oi(_) && (An(_.key), E = "" + _.key), Si(_) && (z = _.ref, Ei(_, C));
        for (P in _)
          Re.call(_, P) && !vi.hasOwnProperty(P) && (j[P] = _[P]);
        if (h && h.defaultProps) {
          var $ = h.defaultProps;
          for (P in $)
            j[P] === void 0 && (j[P] = $[P]);
        }
        if (E || z) {
          var D = typeof h == "function" ? h.displayName || h.name || "Unknown" : h;
          E && Ai(j, D), z && ji(j, D);
        }
        return ki(h, E, z, C, O, jn.current, j);
      }
    }
    var St = T.ReactCurrentOwner, Pn = T.ReactDebugCurrentFrame;
    function we(h) {
      if (h) {
        var _ = h._owner, w = Ze(h.type, h._source, _ ? _.type : null);
        Pn.setExtraStackFrame(w);
      } else
        Pn.setExtraStackFrame(null);
    }
    var Ot;
    Ot = !1;
    function Et(h) {
      return typeof h == "object" && h !== null && h.$$typeof === n;
    }
    function In() {
      {
        if (St.current) {
          var h = ne(St.current.type);
          if (h)
            return `

Check the render method of \`` + h + "`.";
        }
        return "";
      }
    }
    function Pi(h) {
      return "";
    }
    var Mn = {};
    function Ii(h) {
      {
        var _ = In();
        if (!_) {
          var w = typeof h == "string" ? h : h.displayName || h.name;
          w && (_ = `

Check the top-level render call using <` + w + ">.");
        }
        return _;
      }
    }
    function Rn(h, _) {
      {
        if (!h._store || h._store.validated || h.key != null)
          return;
        h._store.validated = !0;
        var w = Ii(_);
        if (Mn[w])
          return;
        Mn[w] = !0;
        var O = "";
        h && h._owner && h._owner !== St.current && (O = " It was passed a child from " + ne(h._owner.type) + "."), we(h), v('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', w, O), we(null);
      }
    }
    function $n(h, _) {
      {
        if (typeof h != "object")
          return;
        if (vt(h))
          for (var w = 0; w < h.length; w++) {
            var O = h[w];
            Et(O) && Rn(O, _);
          }
        else if (Et(h))
          h._store && (h._store.validated = !0);
        else if (h) {
          var C = m(h);
          if (typeof C == "function" && C !== h.entries)
            for (var P = C.call(h), j; !(j = P.next()).done; )
              Et(j.value) && Rn(j.value, _);
        }
      }
    }
    function Mi(h) {
      {
        var _ = h.type;
        if (_ == null || typeof _ == "string")
          return;
        var w;
        if (typeof _ == "function")
          w = _.propTypes;
        else if (typeof _ == "object" && (_.$$typeof === d || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        _.$$typeof === l))
          w = _.propTypes;
        else
          return;
        if (w) {
          var O = ne(_);
          gi(w, h.props, "prop", O, h);
        } else if (_.PropTypes !== void 0 && !Ot) {
          Ot = !0;
          var C = ne(_);
          v("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", C || "Unknown");
        }
        typeof _.getDefaultProps == "function" && !_.getDefaultProps.isReactClassApproved && v("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Ri(h) {
      {
        for (var _ = Object.keys(h.props), w = 0; w < _.length; w++) {
          var O = _[w];
          if (O !== "children" && O !== "key") {
            we(h), v("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", O), we(null);
            break;
          }
        }
        h.ref !== null && (we(h), v("Invalid attribute `ref` supplied to `React.Fragment`."), we(null));
      }
    }
    var xn = {};
    function Dn(h, _, w, O, C, P) {
      {
        var j = _t(h);
        if (!j) {
          var E = "";
          (h === void 0 || typeof h == "object" && h !== null && Object.keys(h).length === 0) && (E += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var z = Pi();
          z ? E += z : E += In();
          var $;
          h === null ? $ = "null" : vt(h) ? $ = "array" : h !== void 0 && h.$$typeof === n ? ($ = "<" + (ne(h.type) || "Unknown") + " />", E = " Did you accidentally export a JSX literal instead of a component?") : $ = typeof h, v("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", $, E);
        }
        var D = Ci(h, _, w, C, P);
        if (D == null)
          return D;
        if (j) {
          var J = _.children;
          if (J !== void 0)
            if (O)
              if (vt(J)) {
                for (var ve = 0; ve < J.length; ve++)
                  $n(J[ve], h);
                Object.freeze && Object.freeze(J);
              } else
                v("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              $n(J, h);
        }
        if (Re.call(_, "key")) {
          var he = ne(h), W = Object.keys(_).filter(function(Fi) {
            return Fi !== "key";
          }), At = W.length > 0 ? "{key: someKey, " + W.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!xn[he + At]) {
            var Li = W.length > 0 ? "{" + W.join(": ..., ") + ": ...}" : "{}";
            v(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, At, he, Li, he), xn[he + At] = !0;
          }
        }
        return h === i ? Ri(D) : Mi(D), D;
      }
    }
    function $i(h, _, w) {
      return Dn(h, _, w, !0);
    }
    function xi(h, _, w) {
      return Dn(h, _, w, !1);
    }
    var Di = xi, Ui = $i;
    xe.Fragment = i, xe.jsx = Di, xe.jsxs = Ui;
  }(), xe;
}
var qi = {};
qi.NODE_ENV === "production" ? $t.exports = Ni() : $t.exports = Ki();
var et = $t.exports;
function N(t) {
  if (typeof t == "number")
    return (Math.abs(t * 2654435761) >>> 0).toString(16);
  if (typeof t == "boolean")
    return t ? "1" : "0";
  if (t === null)
    return "null";
  if (t === void 0)
    return "undefined";
  if (typeof t == "string") {
    let e = 2166136261;
    for (let n = 0; n < t.length; n++)
      e ^= t.charCodeAt(n), e += (e << 1) + (e << 4) + (e << 7) + (e << 8) + (e << 24), e = e >>> 0;
    return e.toString(16);
  }
  if (Array.isArray(t)) {
    let e = 2166136261;
    for (let n = 0; n < t.length; n++) {
      e ^= (n + 1) * 2654435761;
      const r = N(t[n]);
      for (let i = 0; i < r.length; i++)
        e ^= r.charCodeAt(i), e *= 16777619, e = e >>> 0;
    }
    return e.toString(16);
  }
  if (typeof t == "object") {
    let e = 2166136261;
    const n = Object.keys(t).sort();
    for (let r = 0; r < n.length; r++) {
      const i = n[r], s = N(i);
      e ^= parseInt(s, 16), e *= 16777619, e = e >>> 0;
      const o = N(t[i]);
      e ^= parseInt(o, 16), e *= 16777619, e = e >>> 0;
    }
    return e.toString(16);
  }
  return N(String(t));
}
const x = {
  Remove: "remove",
  Replace: "replace",
  Add: "add"
}, Er = Symbol.for("__MUTATIVE_PROXY_DRAFT__"), zi = Symbol("__MUTATIVE_RAW_RETURN_SYMBOL__"), st = Symbol.iterator, Y = {
  mutable: "mutable",
  immutable: "immutable"
}, Xt = {};
function Ne(t, e) {
  return t instanceof Map ? t.has(e) : Object.prototype.hasOwnProperty.call(t, e);
}
function Fn(t, e) {
  if (e in t) {
    let n = Reflect.getPrototypeOf(t);
    for (; n; ) {
      const r = Reflect.getOwnPropertyDescriptor(n, e);
      if (r)
        return r;
      n = Reflect.getPrototypeOf(n);
    }
  }
}
function en(t) {
  return Object.getPrototypeOf(t) === Set.prototype;
}
function tn(t) {
  return Object.getPrototypeOf(t) === Map.prototype;
}
function H(t) {
  var e;
  return (e = t.copy) !== null && e !== void 0 ? e : t.original;
}
function Te(t) {
  return !!A(t);
}
function A(t) {
  return typeof t != "object" ? null : t == null ? void 0 : t[Er];
}
function nn(t) {
  var e;
  const n = A(t);
  return n ? (e = n.copy) !== null && e !== void 0 ? e : n.original : t;
}
function ee(t, e) {
  if (!t || typeof t != "object")
    return !1;
  let n;
  return Object.getPrototypeOf(t) === Object.prototype || Array.isArray(t) || t instanceof Map || t instanceof Set || !!(e != null && e.mark) && ((n = e.mark(t, Y)) === Y.immutable || typeof n == "function");
}
function Ar(t, e = []) {
  if (Object.hasOwnProperty.call(t, "key")) {
    const n = t.parent.copy, r = A(ce(n, t.key));
    if (r !== null && (r == null ? void 0 : r.original) !== t.original)
      return null;
    const i = t.parent.type === 3, s = i ? Array.from(t.parent.setMap.keys()).indexOf(t.key) : t.key;
    if (!(i && n.size > s || Ne(n, s)))
      return null;
    e.push(s);
  }
  if (t.parent)
    return Ar(t.parent, e);
  e.reverse();
  try {
    Vi(t.copy, e);
  } catch {
    return null;
  }
  return e;
}
function me(t) {
  return Array.isArray(t) ? 1 : t instanceof Map ? 2 : t instanceof Set ? 3 : 0;
}
function ce(t, e) {
  return me(t) === 2 ? t.get(e) : t[e];
}
function We(t, e, n) {
  me(t) === 2 ? t.set(e, n) : t[e] = n;
}
function jt(t, e) {
  const n = A(t);
  return (n ? H(n) : t)[e];
}
function ae(t, e) {
  return t === e ? t !== 0 || 1 / t === 1 / e : t !== t && e !== e;
}
function xt(t) {
  if (t)
    for (; t.finalities.revoke.length > 0; )
      t.finalities.revoke.pop()();
}
function be(t, e) {
  return e ? t : [""].concat(t).map((n) => {
    const r = `${n}`;
    return r.indexOf("/") === -1 && r.indexOf("~") === -1 ? r : r.replace(/~/g, "~0").replace(/\//g, "~1");
  }).join("/");
}
function Vi(t, e) {
  for (let n = 0; n < e.length - 1; n += 1) {
    const r = e[n];
    if (t = ce(me(t) === 3 ? Array.from(t) : t, r), typeof t != "object")
      throw new Error(`Cannot resolve patch at '${e.join("/")}'.`);
  }
  return t;
}
function Wi(t) {
  const e = Object.create(Object.getPrototypeOf(t));
  return Reflect.ownKeys(t).forEach((n) => {
    let r = Reflect.getOwnPropertyDescriptor(t, n);
    if (r.enumerable && r.configurable && r.writable) {
      e[n] = t[n];
      return;
    }
    r.writable || (r.writable = !0, r.configurable = !0), (r.get || r.set) && (r = {
      configurable: !0,
      writable: !0,
      enumerable: r.enumerable,
      value: t[n]
    }), Reflect.defineProperty(e, n, r);
  }), e;
}
const Bi = Object.prototype.propertyIsEnumerable;
function jr(t, e) {
  let n;
  if (Array.isArray(t))
    return Array.prototype.concat.call(t);
  if (t instanceof Set) {
    if (!en(t)) {
      const r = Object.getPrototypeOf(t).constructor;
      return new r(t.values());
    }
    return Set.prototype.difference ? Set.prototype.difference.call(t, /* @__PURE__ */ new Set()) : new Set(t.values());
  } else if (t instanceof Map) {
    if (!tn(t)) {
      const r = Object.getPrototypeOf(t).constructor;
      return new r(t);
    }
    return new Map(t);
  } else if (e != null && e.mark && (n = e.mark(t, Y), n !== void 0) && n !== Y.mutable) {
    if (n === Y.immutable)
      return Wi(t);
    if (typeof n == "function") {
      if (e.enablePatches || e.enableAutoFreeze)
        throw new Error("You can't use mark and patches or auto freeze together.");
      return n();
    }
    throw new Error(`Unsupported mark result: ${n}`);
  } else if (typeof t == "object" && Object.getPrototypeOf(t) === Object.prototype) {
    const r = {};
    return Object.keys(t).forEach((i) => {
      r[i] = t[i];
    }), Object.getOwnPropertySymbols(t).forEach((i) => {
      Bi.call(t, i) && (r[i] = t[i]);
    }), r;
  } else
    throw new Error("Please check mark() to ensure that it is a stable marker draftable function.");
}
function V(t) {
  t.copy || (t.copy = jr(t.original, t.options));
}
function Ue(t) {
  if (!ee(t))
    return nn(t);
  if (Array.isArray(t))
    return t.map(Ue);
  if (t instanceof Map) {
    const n = Array.from(t.entries()).map(([r, i]) => [
      r,
      Ue(i)
    ]);
    if (!tn(t)) {
      const r = Object.getPrototypeOf(t).constructor;
      return new r(n);
    }
    return new Map(n);
  }
  if (t instanceof Set) {
    const n = Array.from(t).map(Ue);
    if (!en(t)) {
      const r = Object.getPrototypeOf(t).constructor;
      return new r(n);
    }
    return new Set(n);
  }
  const e = Object.create(Object.getPrototypeOf(t));
  for (const n in t)
    e[n] = Ue(t[n]);
  return e;
}
function ot(t) {
  return Te(t) ? Ue(t) : t;
}
function ie(t) {
  var e;
  t.assignedMap = (e = t.assignedMap) !== null && e !== void 0 ? e : /* @__PURE__ */ new Map(), t.operated || (t.operated = !0, t.parent && ie(t.parent));
}
function Nn() {
  throw new Error("Cannot modify frozen object");
}
function Se(t, e, n, r, i) {
  {
    n = n ?? /* @__PURE__ */ new WeakMap(), r = r ?? [], i = i ?? [];
    const o = n.has(t) ? n.get(t) : t;
    if (r.length > 0) {
      const u = r.indexOf(o);
      if (o && typeof o == "object" && u !== -1)
        throw r[0] === o ? new Error("Forbids circular reference") : new Error(`Forbids circular reference: ~/${i.slice(0, u).map((a, d) => {
          if (typeof a == "symbol")
            return `[${a.toString()}]`;
          const c = r[d];
          return typeof a == "object" && (c instanceof Map || c instanceof Set) ? Array.from(c.keys()).indexOf(a) : a;
        }).join("/")}`);
      r.push(o), i.push(e);
    } else
      r.push(o);
  }
  if (Object.isFrozen(t) || Te(t)) {
    r.pop(), i.pop();
    return;
  }
  switch (me(t)) {
    case 2:
      for (const [u, a] of t)
        Se(u, u, n, r, i), Se(a, u, n, r, i);
      t.set = t.clear = t.delete = Nn;
      break;
    case 3:
      for (const u of t)
        Se(u, u, n, r, i);
      t.add = t.clear = t.delete = Nn;
      break;
    case 1:
      Object.freeze(t);
      let o = 0;
      for (const u of t)
        Se(u, o, n, r, i), o += 1;
      break;
    default:
      Object.freeze(t), Object.keys(t).forEach((u) => {
        const a = t[u];
        Se(a, u, n, r, i);
      });
  }
  r.pop(), i.pop();
}
function rn(t, e) {
  const n = me(t);
  if (n === 0)
    Reflect.ownKeys(t).forEach((r) => {
      e(r, t[r], t);
    });
  else if (n === 1) {
    let r = 0;
    for (const i of t)
      e(r, i, t), r += 1;
  } else
    t.forEach((r, i) => e(i, r, t));
}
function kr(t, e, n) {
  if (Te(t) || !ee(t, n) || e.has(t) || Object.isFrozen(t))
    return;
  const r = t instanceof Set, i = r ? /* @__PURE__ */ new Map() : void 0;
  if (e.add(t), rn(t, (s, o) => {
    var u;
    if (Te(o)) {
      const a = A(o);
      V(a);
      const d = !((u = a.assignedMap) === null || u === void 0) && u.size || a.operated ? a.copy : a.original;
      We(r ? i : t, s, d);
    } else
      kr(o, e, n);
  }), i) {
    const s = t, o = Array.from(s);
    s.clear(), o.forEach((u) => {
      s.add(i.has(u) ? i.get(u) : u);
    });
  }
}
function Gi(t, e) {
  const n = t.type === 3 ? t.setMap : t.copy;
  t.finalities.revoke.length > 1 && t.assignedMap.get(e) && n && kr(ce(n, e), t.finalities.handledSet, t.options);
}
function Dt(t) {
  t.type === 3 && t.copy && (t.copy.clear(), t.setMap.forEach((e) => {
    t.copy.add(nn(e));
  }));
}
function Ut(t, e, n, r) {
  if (t.operated && t.assignedMap && t.assignedMap.size > 0 && !t.finalized) {
    if (n && r) {
      const s = Ar(t);
      s && e(t, s, n, r);
    }
    t.finalized = !0;
  }
}
function sn(t, e, n, r) {
  const i = A(n);
  i && (i.callbacks || (i.callbacks = []), i.callbacks.push((s, o) => {
    var u;
    const a = t.type === 3 ? t.setMap : t.copy;
    if (ae(ce(a, e), n)) {
      let d = i.original;
      i.copy && (d = i.copy), Dt(t), Ut(t, r, s, o), t.options.enableAutoFreeze && (t.options.updatedValues = (u = t.options.updatedValues) !== null && u !== void 0 ? u : /* @__PURE__ */ new WeakMap(), t.options.updatedValues.set(d, i.original)), We(a, e, d);
    }
  }), t.options.enableAutoFreeze && i.finalities !== t.finalities && (t.options.enableAutoFreeze = !1)), ee(n, t.options) && t.finalities.draft.push(() => {
    const s = t.type === 3 ? t.setMap : t.copy;
    ae(ce(s, e), n) && Gi(t, e);
  });
}
function Qi(t, e, n, r, i) {
  let { original: s, assignedMap: o, options: u } = t, a = t.copy;
  a.length < s.length && ([s, a] = [a, s], [n, r] = [r, n]);
  for (let d = 0; d < s.length; d += 1)
    if (o.get(d.toString()) && a[d] !== s[d]) {
      const c = e.concat([d]), f = be(c, i);
      n.push({
        op: x.Replace,
        path: f,
        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
        value: ot(a[d])
      }), r.push({
        op: x.Replace,
        path: f,
        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
        value: ot(s[d])
      });
    }
  for (let d = s.length; d < a.length; d += 1) {
    const c = e.concat([d]), f = be(c, i);
    n.push({
      op: x.Add,
      path: f,
      // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
      value: ot(a[d])
    });
  }
  if (s.length < a.length) {
    const { arrayLengthAssignment: d = !0 } = u.enablePatches;
    if (d) {
      const c = e.concat(["length"]), f = be(c, i);
      r.push({
        op: x.Replace,
        path: f,
        value: s.length
      });
    } else
      for (let c = a.length; s.length < c; c -= 1) {
        const f = e.concat([c - 1]), l = be(f, i);
        r.push({
          op: x.Remove,
          path: l
        });
      }
  }
}
function Hi({ original: t, copy: e, assignedMap: n }, r, i, s, o) {
  n.forEach((u, a) => {
    const d = ce(t, a), c = ot(ce(e, a)), f = u ? Ne(t, a) ? x.Replace : x.Add : x.Remove;
    if (ae(d, c) && f === x.Replace)
      return;
    const l = r.concat(a), p = be(l, o);
    i.push(f === x.Remove ? { op: f, path: p } : { op: f, path: p, value: c }), s.push(f === x.Add ? { op: x.Remove, path: p } : f === x.Remove ? { op: x.Add, path: p, value: d } : { op: x.Replace, path: p, value: d });
  });
}
function Yi({ original: t, copy: e }, n, r, i, s) {
  let o = 0;
  t.forEach((u) => {
    if (!e.has(u)) {
      const a = n.concat([o]), d = be(a, s);
      r.push({
        op: x.Remove,
        path: d,
        value: u
      }), i.unshift({
        op: x.Add,
        path: d,
        value: u
      });
    }
    o += 1;
  }), o = 0, e.forEach((u) => {
    if (!t.has(u)) {
      const a = n.concat([o]), d = be(a, s);
      r.push({
        op: x.Add,
        path: d,
        value: u
      }), i.unshift({
        op: x.Remove,
        path: d,
        value: u
      });
    }
    o += 1;
  });
}
function Ve(t, e, n, r) {
  const { pathAsArray: i = !0 } = t.options.enablePatches;
  switch (t.type) {
    case 0:
    case 2:
      return Hi(t, e, n, r, i);
    case 1:
      return Qi(t, e, n, r, i);
    case 3:
      return Yi(t, e, n, r, i);
  }
}
const ct = (t, e, n = !1) => {
  if (typeof t == "object" && t !== null && (!ee(t, e) || n))
    throw new Error("Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.");
}, Lt = {
  get size() {
    return H(A(this)).size;
  },
  has(t) {
    return H(A(this)).has(t);
  },
  set(t, e) {
    const n = A(this), r = H(n);
    return (!r.has(t) || !ae(r.get(t), e)) && (V(n), ie(n), n.assignedMap.set(t, !0), n.copy.set(t, e), sn(n, t, e, Ve)), this;
  },
  delete(t) {
    if (!this.has(t))
      return !1;
    const e = A(this);
    return V(e), ie(e), e.original.has(t) ? e.assignedMap.set(t, !1) : e.assignedMap.delete(t), e.copy.delete(t), !0;
  },
  clear() {
    const t = A(this);
    if (this.size) {
      V(t), ie(t), t.assignedMap = /* @__PURE__ */ new Map();
      for (const [e] of t.original)
        t.assignedMap.set(e, !1);
      t.copy.clear();
    }
  },
  forEach(t, e) {
    const n = A(this);
    H(n).forEach((r, i) => {
      t.call(e, this.get(i), i, this);
    });
  },
  get(t) {
    var e, n;
    const r = A(this), i = H(r).get(t), s = ((n = (e = r.options).mark) === null || n === void 0 ? void 0 : n.call(e, i, Y)) === Y.mutable;
    if (r.options.strict && ct(i, r.options, s), s || r.finalized || !ee(i, r.options) || i !== r.original.get(t))
      return i;
    const o = Xt.createDraft({
      original: i,
      parentDraft: r,
      key: t,
      finalities: r.finalities,
      options: r.options
    });
    return V(r), r.copy.set(t, o), o;
  },
  keys() {
    return H(A(this)).keys();
  },
  values() {
    const t = this.keys();
    return {
      [st]: () => this.values(),
      next: () => {
        const e = t.next();
        return e.done ? e : {
          done: !1,
          value: this.get(e.value)
        };
      }
    };
  },
  entries() {
    const t = this.keys();
    return {
      [st]: () => this.entries(),
      next: () => {
        const e = t.next();
        if (e.done)
          return e;
        const n = this.get(e.value);
        return {
          done: !1,
          value: [e.value, n]
        };
      }
    };
  },
  [st]() {
    return this.entries();
  }
}, Ji = Reflect.ownKeys(Lt), Kn = (t, e, { isValuesIterator: n }) => () => {
  var r, i;
  const s = e.next();
  if (s.done)
    return s;
  const o = s.value;
  let u = t.setMap.get(o);
  const a = A(u), d = ((i = (r = t.options).mark) === null || i === void 0 ? void 0 : i.call(r, u, Y)) === Y.mutable;
  if (t.options.strict && ct(o, t.options, d), !d && !a && ee(o, t.options) && !t.finalized && t.original.has(o)) {
    const c = Xt.createDraft({
      original: o,
      parentDraft: t,
      key: o,
      finalities: t.finalities,
      options: t.options
    });
    t.setMap.set(o, c), u = c;
  } else a && (u = a.proxy);
  return {
    done: !1,
    value: n ? u : [u, u]
  };
}, dt = {
  get size() {
    return A(this).setMap.size;
  },
  has(t) {
    const e = A(this);
    if (e.setMap.has(t))
      return !0;
    V(e);
    const n = A(t);
    return !!(n && e.setMap.has(n.original));
  },
  add(t) {
    const e = A(this);
    return this.has(t) || (V(e), ie(e), e.assignedMap.set(t, !0), e.setMap.set(t, t), sn(e, t, t, Ve)), this;
  },
  delete(t) {
    if (!this.has(t))
      return !1;
    const e = A(this);
    V(e), ie(e);
    const n = A(t);
    return n && e.setMap.has(n.original) ? (e.assignedMap.set(n.original, !1), e.setMap.delete(n.original)) : (!n && e.setMap.has(t) ? e.assignedMap.set(t, !1) : e.assignedMap.delete(t), e.setMap.delete(t));
  },
  clear() {
    if (!this.size)
      return;
    const t = A(this);
    V(t), ie(t);
    for (const e of t.original)
      t.assignedMap.set(e, !1);
    t.setMap.clear();
  },
  values() {
    const t = A(this);
    V(t);
    const e = t.setMap.keys();
    return {
      [Symbol.iterator]: () => this.values(),
      next: Kn(t, e, { isValuesIterator: !0 })
    };
  },
  entries() {
    const t = A(this);
    V(t);
    const e = t.setMap.keys();
    return {
      [Symbol.iterator]: () => this.entries(),
      next: Kn(t, e, {
        isValuesIterator: !1
      })
    };
  },
  keys() {
    return this.values();
  },
  [st]() {
    return this.values();
  },
  forEach(t, e) {
    const n = this.values();
    let r = n.next();
    for (; !r.done; )
      t.call(e, r.value, r.value, this), r = n.next();
  }
};
Set.prototype.difference && Object.assign(dt, {
  intersection(t) {
    return Set.prototype.intersection.call(new Set(this.values()), t);
  },
  union(t) {
    return Set.prototype.union.call(new Set(this.values()), t);
  },
  difference(t) {
    return Set.prototype.difference.call(new Set(this.values()), t);
  },
  symmetricDifference(t) {
    return Set.prototype.symmetricDifference.call(new Set(this.values()), t);
  },
  isSubsetOf(t) {
    return Set.prototype.isSubsetOf.call(new Set(this.values()), t);
  },
  isSupersetOf(t) {
    return Set.prototype.isSupersetOf.call(new Set(this.values()), t);
  },
  isDisjointFrom(t) {
    return Set.prototype.isDisjointFrom.call(new Set(this.values()), t);
  }
});
const Zi = Reflect.ownKeys(dt), Cr = /* @__PURE__ */ new WeakSet(), Pr = {
  get(t, e, n) {
    var r, i;
    const s = (r = t.copy) === null || r === void 0 ? void 0 : r[e];
    if (s && Cr.has(s))
      return s;
    if (e === Er)
      return t;
    let o;
    if (t.options.mark) {
      const d = e === "size" && (t.original instanceof Map || t.original instanceof Set) ? Reflect.get(t.original, e) : Reflect.get(t.original, e, n);
      if (o = t.options.mark(d, Y), o === Y.mutable)
        return t.options.strict && ct(d, t.options, !0), d;
    }
    const u = H(t);
    if (u instanceof Map && Ji.includes(e)) {
      if (e === "size")
        return Object.getOwnPropertyDescriptor(Lt, "size").get.call(t.proxy);
      const d = Lt[e];
      if (d)
        return d.bind(t.proxy);
    }
    if (u instanceof Set && Zi.includes(e)) {
      if (e === "size")
        return Object.getOwnPropertyDescriptor(dt, "size").get.call(t.proxy);
      const d = dt[e];
      if (d)
        return d.bind(t.proxy);
    }
    if (!Ne(u, e)) {
      const d = Fn(u, e);
      return d ? "value" in d ? d.value : (
        // !case: support for getter
        (i = d.get) === null || i === void 0 ? void 0 : i.call(t.proxy)
      ) : void 0;
    }
    const a = u[e];
    if (t.options.strict && ct(a, t.options), t.finalized || !ee(a, t.options))
      return a;
    if (a === jt(t.original, e)) {
      if (V(t), t.copy[e] = on({
        original: t.original[e],
        parentDraft: t,
        key: t.type === 1 ? Number(e) : e,
        finalities: t.finalities,
        options: t.options
      }), typeof o == "function") {
        const d = A(t.copy[e]);
        return V(d), ie(d), d.copy;
      }
      return t.copy[e];
    }
    return a;
  },
  set(t, e, n) {
    var r;
    if (t.type === 3 || t.type === 2)
      throw new Error("Map/Set draft does not support any property assignment.");
    let i;
    if (t.type === 1 && e !== "length" && !(Number.isInteger(i = Number(e)) && i >= 0 && (e === 0 || i === 0 || String(i) === String(e))))
      throw new Error("Only supports setting array indices and the 'length' property.");
    const s = Fn(H(t), e);
    if (s != null && s.set)
      return s.set.call(t.proxy, n), !0;
    const o = jt(H(t), e), u = A(o);
    return u && ae(u.original, n) ? (t.copy[e] = n, t.assignedMap = (r = t.assignedMap) !== null && r !== void 0 ? r : /* @__PURE__ */ new Map(), t.assignedMap.set(e, !1), !0) : (ae(n, o) && (n !== void 0 || Ne(t.original, e)) || (V(t), ie(t), Ne(t.original, e) && ae(n, t.original[e]) ? t.assignedMap.delete(e) : t.assignedMap.set(e, !0), t.copy[e] = n, sn(t, e, n, Ve)), !0);
  },
  has(t, e) {
    return e in H(t);
  },
  ownKeys(t) {
    return Reflect.ownKeys(H(t));
  },
  getOwnPropertyDescriptor(t, e) {
    const n = H(t), r = Reflect.getOwnPropertyDescriptor(n, e);
    return r && {
      writable: !0,
      configurable: t.type !== 1 || e !== "length",
      enumerable: r.enumerable,
      value: n[e]
    };
  },
  getPrototypeOf(t) {
    return Reflect.getPrototypeOf(t.original);
  },
  setPrototypeOf() {
    throw new Error("Cannot call 'setPrototypeOf()' on drafts");
  },
  defineProperty() {
    throw new Error("Cannot call 'defineProperty()' on drafts");
  },
  deleteProperty(t, e) {
    var n;
    return t.type === 1 ? Pr.set.call(this, t, e, void 0, t.proxy) : (jt(t.original, e) !== void 0 || e in t.original ? (V(t), ie(t), t.assignedMap.set(e, !1)) : (t.assignedMap = (n = t.assignedMap) !== null && n !== void 0 ? n : /* @__PURE__ */ new Map(), t.assignedMap.delete(e)), t.copy && delete t.copy[e], !0);
  }
};
function on(t) {
  const { original: e, parentDraft: n, key: r, finalities: i, options: s } = t, o = me(e), u = {
    type: o,
    finalized: !1,
    parent: n,
    original: e,
    copy: null,
    proxy: null,
    finalities: i,
    options: s,
    // Mapping of draft Set items to their corresponding draft values.
    setMap: o === 3 ? new Map(e.entries()) : void 0
  };
  (r || "key" in t) && (u.key = r);
  const { proxy: a, revoke: d } = Proxy.revocable(o === 1 ? Object.assign([], u) : u, Pr);
  if (i.revoke.push(d), Cr.add(a), u.proxy = a, n) {
    const c = n;
    c.finalities.draft.push((f, l) => {
      var p, y;
      const b = A(a);
      let g = c.type === 3 ? c.setMap : c.copy;
      const m = ce(g, r), T = A(m);
      if (T) {
        let v = T.original;
        T.operated && (v = nn(m)), Dt(T), Ut(T, Ve, f, l), c.options.enableAutoFreeze && (c.options.updatedValues = (p = c.options.updatedValues) !== null && p !== void 0 ? p : /* @__PURE__ */ new WeakMap(), c.options.updatedValues.set(v, T.original)), We(g, r, v);
      }
      (y = b.callbacks) === null || y === void 0 || y.forEach((v) => {
        v(f, l);
      });
    });
  } else {
    const c = A(a);
    c.finalities.draft.push((f, l) => {
      Dt(c), Ut(c, Ve, f, l);
    });
  }
  return a;
}
Xt.createDraft = on;
function Xi(t, e, n, r, i) {
  var s;
  const o = A(t), u = (s = o == null ? void 0 : o.original) !== null && s !== void 0 ? s : t, a = !!e.length;
  if (o != null && o.operated)
    for (; o.finalities.draft.length > 0; )
      o.finalities.draft.pop()(n, r);
  const d = a ? e[0] : o ? o.operated ? o.copy : o.original : t;
  return o && xt(o), i && Se(d, d, o == null ? void 0 : o.options.updatedValues), [
    d,
    n && a ? [{ op: x.Replace, path: [], value: e[0] }] : n,
    r && a ? [{ op: x.Replace, path: [], value: u }] : r
  ];
}
function es(t, e) {
  var n;
  const r = {
    draft: [],
    revoke: [],
    handledSet: /* @__PURE__ */ new WeakSet()
  };
  let i, s;
  e.enablePatches && (i = [], s = []);
  const u = ((n = e.mark) === null || n === void 0 ? void 0 : n.call(e, t, Y)) === Y.mutable || !ee(t, e) ? t : on({
    original: t,
    parentDraft: null,
    finalities: r,
    options: e
  });
  return [
    u,
    (a = []) => {
      const [d, c, f] = Xi(u, a, i, s, e.enableAutoFreeze);
      return e.enablePatches ? [d, c, f] : d;
    }
  ];
}
function Ft(t) {
  const { rootDraft: e, value: n, useRawReturn: r = !1, isRoot: i = !0 } = t;
  rn(n, (s, o, u) => {
    const a = A(o);
    if (a && e && a.finalities === e.finalities) {
      t.isContainDraft = !0;
      const d = a.original;
      if (u instanceof Set) {
        const c = Array.from(u);
        u.clear(), c.forEach((f) => u.add(s === f ? d : f));
      } else
        We(u, s, d);
    } else typeof o == "object" && o !== null && (t.value = o, t.isRoot = !1, Ft(t));
  }), i && (t.isContainDraft || console.warn("The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance."), r && console.warn("The return value contains drafts, please don't use 'rawReturn()' to wrap the return value."));
}
function Ir(t) {
  var e;
  const n = A(t);
  if (!ee(t, n == null ? void 0 : n.options))
    return t;
  const r = me(t);
  if (n && !n.operated)
    return n.original;
  let i;
  function s() {
    i = r === 2 ? tn(t) ? new Map(t) : new (Object.getPrototypeOf(t)).constructor(t) : r === 3 ? Array.from(n.setMap.values()) : jr(t, n == null ? void 0 : n.options);
  }
  if (n) {
    n.finalized = !0;
    try {
      s();
    } finally {
      n.finalized = !1;
    }
  } else
    i = t;
  if (rn(i, (o, u) => {
    if (n && ae(ce(n.original, o), u))
      return;
    const a = Ir(u);
    a !== u && (i === t && s(), We(i, o, a));
  }), r === 3) {
    const o = (e = n == null ? void 0 : n.original) !== null && e !== void 0 ? e : i;
    return en(o) ? new Set(i) : new (Object.getPrototypeOf(o)).constructor(i);
  }
  return i;
}
function qn(t) {
  if (!Te(t))
    throw new Error(`current() is only used for Draft, parameter: ${t}`);
  return Ir(t);
}
const ts = (t) => function e(n, r, i) {
  var s, o, u;
  if (typeof n == "function" && typeof r != "function")
    return function(S, ...I) {
      return e(S, (R) => n.call(this, R, ...I), r);
    };
  const a = n, d = r;
  let c = i;
  if (typeof r != "function" && (c = r), c !== void 0 && Object.prototype.toString.call(c) !== "[object Object]")
    throw new Error(`Invalid options: ${c}, 'options' should be an object.`);
  c = Object.assign(Object.assign({}, t), c);
  const f = Te(a) ? qn(a) : a, l = Array.isArray(c.mark) ? (S, I) => {
    for (const R of c.mark) {
      if (typeof R != "function")
        throw new Error(`Invalid mark: ${R}, 'mark' should be a function.`);
      const q = R(S, I);
      if (q)
        return q;
    }
  } : c.mark, p = (s = c.enablePatches) !== null && s !== void 0 ? s : !1, y = (o = c.strict) !== null && o !== void 0 ? o : !1, g = {
    enableAutoFreeze: (u = c.enableAutoFreeze) !== null && u !== void 0 ? u : !1,
    mark: l,
    strict: y,
    enablePatches: p
  };
  if (!ee(f, g) && typeof f == "object" && f !== null)
    throw new Error("Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.");
  const [m, T] = es(f, g);
  if (typeof r != "function") {
    if (!ee(f, g))
      throw new Error("Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.");
    return [m, T];
  }
  let v;
  try {
    v = d(m);
  } catch (S) {
    throw xt(A(m)), S;
  }
  const k = (S) => {
    const I = A(m);
    if (!Te(S)) {
      if (S !== void 0 && !ae(S, m) && (I != null && I.operated))
        throw new Error("Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.");
      const q = S == null ? void 0 : S[zi];
      if (q) {
        const Ie = q[0];
        return g.strict && typeof S == "object" && S !== null && Ft({
          rootDraft: I,
          value: S,
          useRawReturn: !0
        }), T([Ie]);
      }
      if (S !== void 0)
        return typeof S == "object" && S !== null && Ft({ rootDraft: I, value: S }), T([S]);
    }
    if (S === m || S === void 0)
      return T([]);
    const R = A(S);
    if (g === R.options) {
      if (R.operated)
        throw new Error("Cannot return a modified child draft.");
      return T([qn(S)]);
    }
    return T([S]);
  };
  return v instanceof Promise ? v.then(k, (S) => {
    throw xt(A(m)), S;
  }) : k(v);
}, ft = ts();
Object.prototype.constructor.toString();
function Mr(t, e) {
  const n = Object.keys(t), r = Object.keys(e);
  return n.length === r.length && Object.keys(t).every((i) => e.hasOwnProperty(i));
}
function zn(t, e) {
  return Object.keys(t).length === Object.keys(e).length && Object.keys(t).every((n) => e.hasOwnProperty(n) && t[n] === e[n]);
}
function ut(t, e) {
  return typeof t != "object" || typeof e != "object" || t === null || e === null ? t === e : Mr(t, e) ? Object.keys(t).every((n) => ut(t[n], e[n])) : !1;
}
function un(t) {
  if (!Le(t))
    return t;
  const e = {};
  for (const [n, r] of Object.entries(t))
    r !== void 0 && (e[n] = r);
  return e;
}
function Rr(t, e) {
  if (!Le(t) || !Le(e))
    return e;
  const n = Object.assign({}, t);
  for (const r of Object.keys(e)) {
    if (e[r] === void 0)
      continue;
    if (e[r] === null) {
      delete n[r];
      continue;
    }
    const i = Le(t[r]) && Le(e[r]);
    n[r] = i ? Rr(t[r], e[r]) : e[r];
  }
  return n;
}
function Le(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t);
}
function ns(t, e, n) {
  if (!t || e.length === 0)
    return;
  let r = t || {};
  for (let s = 0; s < e.length - 1; s++) {
    const o = e[s];
    (!(o in r) || typeof r[o] != "object") && (r[o] = typeof e[s + 1] == "number" ? [] : {}), r = r[o];
  }
  const i = e[e.length - 1];
  Array.isArray(r) && typeof i == "number" ? r.splice(i, 0, n) : r[i] = n;
}
function Vn(t, e, n) {
  if (!t || e.length === 0)
    return;
  let r = t || {};
  for (let i = 0; i < e.length - 1; i++) {
    const s = e[i];
    (!(s in r) || typeof r[s] != "object") && (r[s] = typeof e[i + 1] == "number" ? [] : {}), r = r[s];
  }
  r[e[e.length - 1]] = n;
}
function $r(t, e) {
  if (!t || e.length === 0)
    return;
  const [n, ...r] = e;
  if (n in t) {
    if (r.length === 0) {
      Array.isArray(t) ? t.splice(n, 1) : delete t[n];
      return;
    }
    $r(t[n], r), rs(t[n]) && delete t[n];
  }
}
function rs(t) {
  return t && Object.keys(t).length === 0;
}
const Wn = /ZULU|YEKT|YEKST|YAPT|YAKT|YAKST|XJT|WGT|WGST|WFT|WETDST|WET|WDT|WAT|WAST|WAKT|WADT|VUT|VOLT|VLAT|VLAST|VET|UZT|UZST|UYT|UYST|UTC|UT|ULAT|ULAST|UCT|TVT|TRUT|TOT|TMT|TKT|TJT|TFT|TAHT|SGT|SCT|SAST|SADT|RET|PYT|PYST|PWT|PST|PONT|PMST|PMDT|PKT|PKST|PHT|PGT|PETT|PETST|PET|PDT|OMST|OMSST|NZT|NZST|NZDT|NUT|NST|NPT|NOVT|NOVST|NFT|NDT|MYT|MVT|MUT|MUST|MST|MSK|MSD|MPT|MMT|MHT|MEZ|METDST|MET|MESZ|MEST|MDT|MAWT|MART|MAGT|MAGST|LKT|LINT|LIGT|LHST|LHDT|KST|KRAT|KRAST|KOST|KGT|KGST|KDT|JST|JAYT|IST|IRT|IRKT|IRKST|IOT|IDT|ICT|HST|HKT|GYT|GMT|GILT|GFT|GET|GEST|GAMT|GALT|FNT|FNST|FKT|FKST|FJT|FJST|FET|EST|EGT|EGST|EETDST|EET|EEST|EDT|EAT|EAST|EASST|DDUT|DAVT|CXT|CST|COT|CLT|CLST|CKT|CHUT|CHAST|CHADT|CETDST|CET|CEST|CDT|CCT|CAST|CADT|BTT|BST|BRT|BRST|BRA|BOT|BORT|BNT|BDT|BDST|AZT|AZST|AZOT|AZOST|AWST|AWSST|AST|ART|ARST|ANAT|ANAST|AMT|AMST|ALMT|ALMST|AKST|AKDT|AFT|AEST|AESST|AEDT|ADT|ACWST|ACT|ACST|ACSST|ACDT$/, is = {
  ZULU: 0,
  YEKT: 18e3,
  YEKST: 21600,
  YAPT: 36e3,
  YAKT: 32400,
  YAKST: 32400,
  XJT: 21600,
  WGT: -10800,
  WGST: -7200,
  WFT: 43200,
  WETDST: 3600,
  WET: 0,
  WDT: 32400,
  WAT: 3600,
  WAST: 25200,
  WAKT: 43200,
  WADT: 28800,
  VUT: 39600,
  VOLT: 10800,
  VLAT: 36e3,
  VLAST: 36e3,
  VET: -14400,
  UZT: 18e3,
  UZST: 21600,
  UYT: -10800,
  UYST: -7200,
  UTC: 0,
  UT: 0,
  ULAT: 28800,
  ULAST: 32400,
  UCT: 0,
  TVT: 43200,
  TRUT: 36e3,
  TOT: 46800,
  TMT: 18e3,
  TKT: 46800,
  TJT: 18e3,
  TFT: 18e3,
  TAHT: -36e3,
  SGT: 28800,
  SCT: 14400,
  SAST: 7200,
  SADT: 37800,
  RET: 14400,
  PYT: -14400,
  PYST: -10800,
  PWT: 32400,
  PST: -28800,
  PONT: 39600,
  PMST: -10800,
  PMDT: -7200,
  PKT: 18e3,
  PKST: 21600,
  PHT: 28800,
  PGT: 36e3,
  PETT: 43200,
  PETST: 43200,
  PET: -18e3,
  PDT: -25200,
  OMST: 21600,
  OMSST: 21600,
  NZT: 43200,
  NZST: 43200,
  NZDT: 46800,
  NUT: -39600,
  NST: -12600,
  NPT: 20700,
  NOVT: 25200,
  NOVST: 25200,
  NFT: -12600,
  NDT: -9e3,
  MYT: 28800,
  MVT: 18e3,
  MUT: 14400,
  MUST: 18e3,
  MST: -25200,
  MSK: 10800,
  MSD: 14400,
  MPT: 36e3,
  MMT: 23400,
  MHT: 43200,
  MEZ: 3600,
  METDST: 7200,
  MET: 3600,
  MESZ: 7200,
  MEST: 7200,
  MDT: -21600,
  MAWT: 18e3,
  MART: -34200,
  MAGT: 39600,
  MAGST: 39600,
  LKT: 19800,
  LINT: 50400,
  LIGT: 36e3,
  LHST: 37800,
  LHDT: 37800,
  KST: 32400,
  KRAT: 25200,
  KRAST: 25200,
  KOST: 39600,
  KGT: 21600,
  KGST: 21600,
  KDT: 36e3,
  JST: 32400,
  JAYT: 32400,
  IST: 7200,
  IRT: 12600,
  IRKT: 28800,
  IRKST: 28800,
  IOT: 21600,
  IDT: 10800,
  ICT: 25200,
  HST: -36e3,
  HKT: 28800,
  GYT: -14400,
  GMT: 0,
  GILT: 43200,
  GFT: -10800,
  GET: 14400,
  GEST: 14400,
  GAMT: -32400,
  GALT: -21600,
  FNT: -7200,
  FNST: -3600,
  FKT: -10800,
  FKST: -10800,
  FJT: 43200,
  FJST: 46800,
  FET: 10800,
  EST: -18e3,
  EGT: -3600,
  EGST: 0,
  EETDST: 10800,
  EET: 7200,
  EEST: 10800,
  EDT: -14400,
  EAT: 10800,
  EAST: -21600,
  EASST: -21600,
  DDUT: 36e3,
  DAVT: 25200,
  CXT: 25200,
  CST: -21600,
  COT: -18e3,
  CLT: -14400,
  CLST: -10800,
  CKT: -36e3,
  CHUT: 36e3,
  CHAST: 45900,
  CHADT: 49500,
  CETDST: 7200,
  CET: 3600,
  CEST: 7200,
  CDT: -18e3,
  CCT: 28800,
  CAST: 34200,
  CADT: 37800,
  BTT: 21600,
  BST: 3600,
  BRT: -10800,
  BRST: -7200,
  BRA: -10800,
  BOT: -14400,
  BORT: 28800,
  BNT: 28800,
  BDT: 21600,
  BDST: 7200,
  AZT: 14400,
  AZST: 14400,
  AZOT: -3600,
  AZOST: 0,
  AWST: 28800,
  AWSST: 32400,
  AST: -14400,
  ART: -10800,
  ARST: -10800,
  ANAT: 43200,
  ANAST: 43200,
  AMT: -14400,
  AMST: 14400,
  ALMT: 21600,
  ALMST: 25200,
  AKST: -32400,
  AKDT: -28800,
  AFT: 16200,
  AEST: 36e3,
  AESST: 39600,
  AEDT: 39600,
  ADT: -10800,
  ACWST: 31500,
  ACT: -18e3,
  ACST: 34200,
  ACSST: 37800,
  ACDT: 37800
};
function ss(t) {
  return new Date(t);
}
function os(t) {
  return /* @__PURE__ */ new Date(t + "Z");
}
const us = /^(\d+)[\./-](\d+)[\./-](\d+)$/;
function as(t) {
  const e = t.match(us);
  if (!e)
    return null;
  const [n, r, i, s] = e;
  return r <= 0 || i <= 0 || s <= 0 ? null : r > 999 ? new Date(Date.UTC(r, i - 1, s, 0, 0, 0, 0)) : new Date(Date.UTC(s, r - 1, i, 0, 0, 0, 0));
}
function cs(t) {
  const [e, n] = t.split(" ");
  return /* @__PURE__ */ new Date(e + "T" + n + "Z");
}
function ds(t) {
  const [e, n] = t.split(" ");
  return /* @__PURE__ */ new Date(e + "T" + n + "Z");
}
function fs(t) {
  return new Date(t);
}
function ls(t) {
  const e = /^(\w{3}) (\w{3}) (\d{2}) (\d{4})$/;
  if (!t.match(e))
    throw new Error(`Unable to parse \`${t}\` as a date.`);
  const r = /* @__PURE__ */ new Date(t + " UTC");
  return new Date(Date.UTC(r.getUTCFullYear(), r.getUTCMonth(), r.getUTCDate(), 0, 0, 0, 0));
}
function hs(t) {
  const e = /^(.+T.+)([+-])(\d{2})$/, n = t.match(e);
  if (n) {
    const [, r, i, s] = n, o = `${r}${i}${s}:00`;
    return new Date(o);
  }
  return null;
}
function ps(t) {
  const e = /^(\d+)-(\d{1,2})-(\d{1,2})([ T])(.+)$/, n = t.match(e);
  if (n) {
    const [, r, i, s, o, u] = n, a = i.padStart(2, "0"), d = s.padStart(2, "0"), c = `${r}-${a}-${d}T${u}`;
    return new Date(c);
  }
  return null;
}
function ys(t) {
  const [e, n] = t.split(", "), [r, i, s] = e.split("/").map(Number), o = n.match(/(\d{1,2}):(\d{2}):(\d{2}) (AM|PM)/);
  if (!o)
    throw new Error(`Unable to parse time from: ${t}`);
  let [, u, a, d, c] = o;
  return u = Number(u), a = Number(a), d = Number(d), c === "PM" && u !== 12 ? u += 12 : c === "AM" && u === 12 && (u = 0), new Date(Date.UTC(s, r - 1, i, u, a, d));
}
function bs(t) {
  switch (t) {
    case "epoch":
      return /* @__PURE__ */ new Date(0);
    case "infinity":
    case "-infinity":
    case "today":
    case "tomorrow":
    case "yesterday":
      return null;
  }
}
function _s(t) {
  const e = t.match(Wn);
  if (!e)
    return null;
  const [n] = e, r = is[n], i = new Date(t.replace(Wn, "Z"));
  return new Date(i.getTime() - r * 1e3);
}
const gs = [
  as,
  ds,
  ls,
  ys,
  fs,
  os,
  hs,
  cs,
  ss,
  bs,
  _s,
  ps
];
function Ts(t, e) {
  try {
    const n = t(e);
    return n instanceof Date && !isNaN(n.getTime()) ? n : null;
  } catch {
    return null;
  }
}
function Nt(t) {
  for (const e of gs) {
    const n = Ts(e, t);
    if (n)
      return n;
  }
  return null;
}
function ms(t) {
  try {
    const e = JSON.parse(t);
    return typeof e == "string" ? Nt(e) : null;
  } catch {
    return null;
  }
}
function pt(t) {
  if (t !== void 0) {
    if (t === null)
      return null;
    if (t instanceof Date)
      return t;
    if (typeof t == "string") {
      const e = Nt(t) || ms(t) || Nt(t.trim());
      if (!e)
        throw new Error(`Unable to parse \`${t}\` as a date.`);
      return e;
    } else if (typeof t == "number")
      return new Date(t);
    throw new Error(`Invalid date value \`${t}\`. Expected a date, number, or string, got type ${typeof t}.`);
  }
}
function ws(t) {
  return t.cardinality === "one";
}
function an(t) {
  return t["value-type"] === "ref";
}
function cn(t) {
  return t["value-type"] === "blob";
}
function ke(t, e) {
  return t[e];
}
function Ce(t, e) {
  return e.reduce((n, r) => n && n.get(r), t);
}
function X(t, e) {
  if (e.length === 0)
    throw new Error("path must have at least one element");
  if (e.length === 1) {
    t.delete(e[0]);
    return;
  }
  const [n, ...r] = e;
  t.has(n) && X(t.get(n), r);
}
function B(t, e, n) {
  if (e.length === 0)
    throw new Error("path must have at least one element");
  if (e.length === 1) {
    t.set(e[0], n);
    return;
  }
  const [r, ...i] = e;
  let s = t.get(r);
  s || (s = /* @__PURE__ */ new Map(), t.set(r, s)), B(s, i, n);
}
function xr(t, e, n) {
  const r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
  for (const o of e) {
    let [u, a, d, c] = o;
    const f = ke(t, a);
    if (!f) {
      console.warn("no such attr", u, t);
      continue;
    }
    f["checked-data-type"] === "date" && n && (d = pt(d), o[2] = d), an(f) && B(s, [d, a, u], o), B(r, [u, a, d], o), B(i, [a, u, d], o);
  }
  return { eav: r, aev: i, vae: s };
}
function Dr(t) {
  const e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
  for (const s of Object.values(t)) {
    const o = s["forward-identity"], [u, a, d] = o, c = s["reverse-identity"];
    if (B(r, [a, d], s), cn(s) && B(e, [a, d], s), s["primary?"] && B(n, [a], s), c) {
      const [f, l, p] = c;
      B(i, [l, p], s);
    }
  }
  return { blobAttrs: e, primaryKeys: n, forwardIdents: r, revIdents: i };
}
function Ur(t) {
  return {
    __type: t.__type,
    attrs: t.attrs,
    triples: G(t.eav, 3),
    cardinalityInference: t.cardinalityInference,
    linkIndex: t.linkIndex,
    useDateObjects: t.useDateObjects
  };
}
function Lr(t) {
  return at(t.attrs, t.triples, t.cardinalityInference, t.linkIndex, t.useDateObjects);
}
function vs(t, e) {
  return Ce(t.eav, [e]) !== void 0;
}
function dn(t) {
  t.attrIndexes = Dr(t.attrs);
}
function at(t, e, n, r, i) {
  const s = xr(t, e, i);
  return s.useDateObjects = i, s.attrs = t, s.attrIndexes = Dr(t), s.cardinalityInference = n, s.linkIndex = r, s.__type = "store", s;
}
function Be(t, e) {
  var n, r;
  let i;
  if (Array.isArray(e[0])) {
    const [o, u] = e[0], a = t.aev.get(o);
    if (!a)
      return null;
    i = (n = G(a, 2).find((c) => c[2] === u)) === null || n === void 0 ? void 0 : n[0];
  } else
    i = e[0];
  if (!i)
    return null;
  const s = e[2];
  if (Array.isArray(s) && s.length === 2 && t.aev.get(s[0])) {
    const [o, u] = s, a = t.aev.get(o);
    if (!a)
      return null;
    const c = (r = G(a, 2).find((b) => b[2] === u)) === null || r === void 0 ? void 0 : r[0];
    if (!c)
      return null;
    const [f, l, p, ...y] = e;
    return [i, l, c, ...y];
  } else {
    const [o, ...u] = e;
    return [i, ...u];
  }
}
function Fr(t, e) {
  const n = Be(t, e);
  if (!n)
    return;
  const [r, i, s] = n, o = ke(t.attrs, i);
  o && (X(t.eav, [r, i, s]), X(t.aev, [i, r, s]), an(o) && X(t.vae, [s, i, r]));
}
let Ss = 0;
function Nr(t, e, n) {
  const [r, i, s] = n;
  let o;
  const u = Ce(t.eav, [r, i, s]);
  return u && (o = u[3]), o || Date.now() * 10 + Ss++;
}
function Kr(t, e) {
  var n;
  const r = Be(t, e);
  if (!r)
    return;
  let [i, s, o] = r;
  const u = ke(t.attrs, s);
  if (!u)
    return;
  u["checked-data-type"] === "date" && t.useDateObjects && (o = pt(o));
  const a = Ce(t.eav, [i, s, o]), d = (n = a == null ? void 0 : a[3]) !== null && n !== void 0 ? n : Nr(t, u, r), c = [i, s, o, d];
  ws(u) ? (B(t.eav, [i, s], /* @__PURE__ */ new Map([[o, c]])), B(t.aev, [s, i], /* @__PURE__ */ new Map([[o, c]]))) : (B(t.eav, [i, s, o], c), B(t.aev, [s, i, o], c)), an(u) && B(t.vae, [o, s, i], c);
}
function Os(t, e) {
  var n;
  const r = Be(t, e);
  if (!r)
    return;
  const [i, s, o] = r, u = ke(t.attrs, s);
  if (!u)
    return;
  if (!cn(u))
    throw new Error("merge operation is not supported for links");
  const a = Ce(t.eav, [i, s]);
  if (!a)
    return;
  const d = (n = a.values().next()) === null || n === void 0 ? void 0 : n.value;
  if (!d)
    return;
  const c = d[2], f = Rr(c, o), l = [
    i,
    s,
    f,
    Nr(t, u, d)
  ];
  B(t.eav, [i, s], /* @__PURE__ */ new Map([[f, l]]));
}
function Kt(t, e) {
  var n, r;
  const [i, s] = e, o = Be(t, [i]);
  if (!o)
    return;
  const [u] = o, a = t.eav.get(u);
  if (a) {
    for (const c of a.keys()) {
      const f = t.attrs[c];
      f && f["on-delete-reverse"] === "cascade" && G(a.get(c), 1).forEach(([l, p, y]) => {
        var b;
        return Kt(t, [y, (b = f["reverse-identity"]) === null || b === void 0 ? void 0 : b[1]]);
      }), // Fall back to deleting everything if we've rehydrated tx-steps from
      // the store that didn't set `etype` in deleteEntity
      (!s || // If we don't know about the attr, let's just get rid of it
      !f || // Make sure it matches the etype
      ((n = f["forward-identity"]) === null || n === void 0 ? void 0 : n[1]) === s) && (X(t.aev, [c, u]), X(t.eav, [u, c]));
    }
    a.size === 0 && X(t.eav, [u]);
  }
  const d = t.vae.get(u) && G(t.vae.get(u), 2);
  d && d.forEach((c) => {
    var f, l, p;
    const [y, b, g] = c, m = t.attrs[b];
    (!s || !m || ((f = m["reverse-identity"]) === null || f === void 0 ? void 0 : f[1]) === s) && (X(t.eav, [y, b, g]), X(t.aev, [b, y, g]), X(t.vae, [g, b, y])), m && m["on-delete"] === "cascade" && ((l = m["reverse-identity"]) === null || l === void 0 ? void 0 : l[1]) === s && Kt(t, [y, (p = m["forward-identity"]) === null || p === void 0 ? void 0 : p[1]]);
  }), ((r = t.vae.get(u)) === null || r === void 0 ? void 0 : r.size) === 0 && X(t.vae, [u]);
}
function qr(t, e) {
  const n = xr(t.attrs, e, t.useDateObjects);
  Object.keys(n).forEach((r) => {
    t[r] = n[r];
  });
}
function Es(t, [e]) {
  t.attrs[e.id] = e, dn(t);
}
function zr(t) {
  return G(t.eav, 3);
}
function As(t, [e]) {
  if (!t.attrs[e])
    return;
  const n = zr(t).filter(([r, i]) => i !== e);
  delete t.attrs[e], dn(t), qr(t, n);
}
function js(t, [e]) {
  const n = t.attrs[e.id];
  n && (t.attrs[e.id] = Object.assign(Object.assign({}, n), e), dn(t), qr(t, zr(t)));
}
function ks(t, e) {
  const [n, ...r] = e;
  switch (n) {
    case "add-triple":
      Kr(t, r);
      break;
    case "deep-merge-triple":
      Os(t, r);
      break;
    case "retract-triple":
      Fr(t, r);
      break;
    case "delete-entity":
      Kt(t, r);
      break;
    case "add-attr":
      Es(t, r);
      break;
    case "delete-attr":
      As(t, r);
      break;
    case "update-attr":
      js(t, r);
      break;
    case "restore-attr":
      break;
    case "rule-params":
      break;
    default:
      throw new Error(`unhandled transaction action: ${n}`);
  }
}
function G(t, e, n = []) {
  if (!t || e === 0)
    return n;
  if (e === 1) {
    for (const r of t.values())
      n.push(r);
    return n;
  }
  for (const r of t.values())
    G(r, e - 1, n);
  return n;
}
function tt(t, e, n) {
  var r;
  const i = [];
  if (n != null && n.hasOwnProperty("$not")) {
    for (const o of e.keys())
      n.$not !== o && i.push(e.get(o));
    return i;
  }
  if (n != null && n.hasOwnProperty("$isNull")) {
    const { attrId: o, isNull: u, reverse: a } = n.$isNull;
    if (a)
      for (const d of e.keys()) {
        const c = t.vae.get(d), f = !c || !c.get(o);
        (u ? f : !f) && i.push(e.get(d));
      }
    else {
      const d = t.aev.get(o);
      for (const c of e.keys()) {
        const f = !d || ((r = d.get(c)) === null || r === void 0 ? void 0 : r.get(null)) || !d.get(c);
        (u ? f : !f) && i.push(e.get(c));
      }
    }
    return i;
  }
  if (n != null && n.$comparator)
    return G(e, 1).filter(n.$op);
  const s = n.in || n.$in || [n];
  for (const o of s) {
    const u = e.get(o);
    u && i.push(u);
  }
  return i;
}
function Cs(t, e, n) {
  let r = "";
  return t !== void 0 && (r += "e"), e !== void 0 && (r += "a"), n !== void 0 && (r += "v"), r;
}
function Ps(t, [e, n, r]) {
  var i, s;
  switch (Cs(e, n, r)) {
    case "e": {
      const u = t.eav.get(e);
      return G(u, 2);
    }
    case "ea": {
      const u = (i = t.eav.get(e)) === null || i === void 0 ? void 0 : i.get(n);
      return G(u, 1);
    }
    case "eav": {
      const u = (s = t.eav.get(e)) === null || s === void 0 ? void 0 : s.get(n);
      return u ? tt(t, u, r) : [];
    }
    case "ev": {
      const u = t.eav.get(e);
      if (!u)
        return [];
      const a = [];
      for (const d of u.values())
        a.push(...tt(t, d, r));
      return a;
    }
    case "a": {
      const u = t.aev.get(n);
      return G(u, 2);
    }
    case "av": {
      const u = t.aev.get(n);
      if (!u)
        return [];
      const a = [];
      for (const d of u.values())
        a.push(...tt(t, d, r));
      return a;
    }
    case "v": {
      const u = [];
      for (const a of t.eav.values())
        for (const d of a.values())
          u.push(...tt(t, d, r));
      return u;
    }
    default:
      return G(t.eav, 3);
  }
}
function Is(t, e, n) {
  var r;
  const i = {};
  if (!e)
    return i;
  for (const [s, o] of e.entries()) {
    const u = (r = t.eav.get(n)) === null || r === void 0 ? void 0 : r.get(o.id), a = G(u, 1);
    for (const d of a)
      i[s] = d[2];
  }
  return i;
}
function fe(t, e, n) {
  var r;
  return (r = t.attrIndexes.forwardIdents.get(e)) === null || r === void 0 ? void 0 : r.get(n);
}
function Vr(t, e, n) {
  var r;
  return (r = t.attrIndexes.revIdents.get(e)) === null || r === void 0 ? void 0 : r.get(n);
}
function Ms(t, e) {
  return t.attrIndexes.blobAttrs.get(e);
}
function Wr(t, e) {
  var n;
  const r = t.attrIndexes.primaryKeys.get(e);
  return r || ((n = t.attrIndexes.forwardIdents.get(e)) === null || n === void 0 ? void 0 : n.get("id"));
}
function Rs(t, e) {
  const n = Be(t, e);
  if (!n)
    return;
  const [r, i, s] = n;
  if (ke(t.attrs, i))
    return Ce(t.eav, [r, i]);
}
function $s(t, e) {
  const n = e.filter(([r, i, s, o, u]) => {
    if (r !== "add-triple" && r !== "deep-merge-triple")
      return !0;
    const a = u == null ? void 0 : u.mode;
    if (a !== "create" && a !== "update")
      return !0;
    let d = !1;
    const c = ke(t.attrs, s);
    if (c) {
      const f = Wr(t, c["forward-identity"][1]);
      d = !!Rs(t, [
        i,
        f == null ? void 0 : f.id,
        i
      ]);
    }
    return !(a === "create" && d || a === "update" && !d);
  });
  return ft(t, (r) => {
    n.forEach((i) => {
      ks(r, i);
    });
  });
}
function xs(t) {
  return typeof t == "string" && t.startsWith("?");
}
function Ds(t, e, n) {
  if (n.hasOwnProperty(t)) {
    const r = n[t];
    return Br(r, e, n);
  }
  return Object.assign(Object.assign({}, n), { [t]: e });
}
function Bn(t, e, n) {
  return t === e ? n : null;
}
function Us(t) {
  switch (typeof t) {
    case "string":
      return t.startsWith("?") ? Ds : Bn;
    default:
      return Bn;
  }
}
const Ls = [
  "in",
  "$in",
  "$not",
  "$isNull",
  "$comparator"
  // covers all of $gt, $lt, etc.
];
function Fs(t) {
  for (const e of Ls)
    if (t.hasOwnProperty(e))
      return !0;
  return !1;
}
function Br(t, e, n) {
  return n ? typeof t == "object" ? Fs(t) ? n : null : Us(t)(t, e, n) : null;
}
function Ns(t, e, n) {
  return t.reduce((r, i, s) => {
    const o = e[s];
    return Br(i, o, r);
  }, n);
}
function Ks(t, e, n) {
  return Vs(t, e, n).map((r) => Ns(e, r, n)).filter((r) => r);
}
function qs(t, e, n) {
  return e.or ? e.or.patterns.flatMap((r) => qt(t, r, n)) : e.and ? e.and.patterns.reduce((r, i) => qt(t, i, r), n) : n.flatMap((r) => Ks(t, e, r));
}
function qt(t, e, n = [{}]) {
  return e.reduce((r, i) => qs(t, i, r), n);
}
function fn(t, e) {
  return Array.isArray(e) ? e.map((n) => fn(t, n)) : xs(e) ? t[e] : e;
}
function zs(t, { find: e, where: n }) {
  return qt(t, n).map((i) => fn(i, e));
}
function Vs(t, e, n) {
  return Ps(t, fn(n, e));
}
const Ws = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
function Ee(t) {
  return typeof t == "string" && Ws.test(t);
}
const F = [];
for (let t = 0; t < 256; ++t)
  F.push((t + 256).toString(16).slice(1));
function Bs(t, e = 0) {
  return (F[t[e + 0]] + F[t[e + 1]] + F[t[e + 2]] + F[t[e + 3]] + "-" + F[t[e + 4]] + F[t[e + 5]] + "-" + F[t[e + 6]] + F[t[e + 7]] + "-" + F[t[e + 8]] + F[t[e + 9]] + "-" + F[t[e + 10]] + F[t[e + 11]] + F[t[e + 12]] + F[t[e + 13]] + F[t[e + 14]] + F[t[e + 15]]).toLowerCase();
}
let kt;
const Gs = new Uint8Array(16);
function Qs() {
  if (!kt) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    kt = crypto.getRandomValues.bind(crypto);
  }
  return kt(Gs);
}
const Hs = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Gn = { randomUUID: Hs };
function Ys(t, e, n) {
  var i;
  if (Gn.randomUUID && !t)
    return Gn.randomUUID();
  t = t || {};
  const r = t.random ?? ((i = t.rng) == null ? void 0 : i.call(t)) ?? Qs();
  if (r.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, Bs(r);
}
function Qn(t) {
  const e = t.replace(/-/g, ""), n = [];
  for (let r = 0; r < e.length; r += 2)
    n.push(parseInt(e.substring(r, r + 2), 16));
  return n;
}
function Js(t, e) {
  for (let n = 0; n < t.length; n++) {
    if (t[n] < e[n])
      return -1;
    if (t[n] > e[n])
      return 1;
  }
  return 0;
}
function Zs(t, e) {
  return Js(Qn(t), Qn(e));
}
function L() {
  return Ys();
}
function Xs(t, e) {
  return t.localeCompare(e);
}
function eo() {
  let t = Xs;
  if (typeof Intl == "object" && Intl.hasOwnProperty("Collator"))
    try {
      t = Intl.Collator("en-US").compare;
    } catch {
    }
  return t;
}
const to = eo();
let no = 0;
function Ke(t) {
  return yt(`_${t}`, no++);
}
function yt(t, e) {
  return `?${t}-${e}`;
}
class Ae extends Error {
  constructor(e) {
    super(e), this.name = "AttrNotFoundError";
  }
}
function ro(t, e) {
  const n = Wr(t, e);
  if (!n)
    throw new Ae(`Could not find id attr for ${e}`);
  return n;
}
function Hn(t, e, n, r) {
  return [io(t, e, n, r)];
}
function io(t, e, n, r) {
  return [
    t(n, r),
    ro(e, n).id,
    t(n, r),
    t("time", r)
  ];
}
function so(t, e, n) {
  return t.map((r) => r === e ? n : r);
}
function Gr(t, e, n, r, i) {
  const s = fe(e, n, i), o = Vr(e, n, i), u = s || o;
  if (!u)
    throw new Ae(`Could not find attr for ${[n, i]}`);
  if (u["value-type"] !== "ref")
    throw new Error(`Attr ${u.id} is not a ref`);
  const [a, d] = u["forward-identity"], [c, f] = u["reverse-identity"], l = r + 1, p = s ? [
    t(d, r),
    u.id,
    t(f, l),
    Ke("time")
  ] : [
    t(d, l),
    u.id,
    t(f, r),
    Ke("time")
  ];
  return [s ? f : d, l, p, u, !!s];
}
function Yn(t, e) {
  if (typeof e != "string")
    return function(o) {
      return !1;
    };
  const r = e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/%/g, ".*").replace(/_/g, "."), i = new RegExp(`^${r}$`, t ? void 0 : "i");
  return function(o) {
    return typeof o != "string" ? !1 : i.test(o);
  };
}
function oo(t, e) {
  if (typeof e != "object" || e.hasOwnProperty("$in") || e.hasOwnProperty("in"))
    return e;
  const n = t["checked-data-type"] === "date";
  if (e.hasOwnProperty("$gt"))
    return {
      $comparator: !0,
      $op: n ? function(i) {
        return new Date(i[2]) > new Date(e.$gt);
      } : function(i) {
        return i[2] > e.$gt;
      }
    };
  if (e.hasOwnProperty("$gte"))
    return {
      $comparator: !0,
      $op: n ? function(i) {
        return new Date(i[2]) >= new Date(e.$gte);
      } : function(i) {
        return i[2] >= e.$gte;
      }
    };
  if (e.hasOwnProperty("$lt"))
    return {
      $comparator: !0,
      $op: n ? function(i) {
        return new Date(i[2]) < new Date(e.$lt);
      } : function(i) {
        return i[2] < e.$lt;
      }
    };
  if (e.hasOwnProperty("$lte"))
    return {
      $comparator: !0,
      $op: n ? function(i) {
        return new Date(i[2]) <= new Date(e.$lte);
      } : function(i) {
        return i[2] <= e.$lte;
      }
    };
  if (e.hasOwnProperty("$like")) {
    const r = Yn(!0, e.$like);
    return {
      $comparator: !0,
      $op: function(s) {
        return r(s[2]);
      }
    };
  }
  if (e.hasOwnProperty("$ilike")) {
    const r = Yn(!1, e.$ilike);
    return {
      $comparator: !0,
      $op: function(s) {
        return r(s[2]);
      }
    };
  }
  return e;
}
function uo(t, e, n, r, i, s) {
  const o = fe(e, n, i), u = Vr(e, n, i), a = o || u;
  if (!a)
    throw new Ae(`No attr for etype = ${n} label = ${i}`);
  if (s != null && s.hasOwnProperty("$isNull")) {
    const d = fe(e, n, "id");
    if (!d)
      throw new Ae(`No attr for etype = ${n} label = id`);
    return [
      t(n, r),
      d.id,
      { $isNull: { attrId: a.id, isNull: s.$isNull, reverse: !o } },
      Ke("time")
    ];
  }
  return o ? [
    t(n, r),
    a.id,
    oo(a, s),
    Ke("time")
  ] : [s, a.id, t(n, r), Ke("time")];
}
function ao(t, e, n, r, i) {
  const [s, o, u] = i.reduce((a, d) => {
    const [c, f, l] = a, [p, y, b] = Gr(t, e, c, f, d);
    return [p, y, [...l, b]];
  }, [n, r, []]);
  return [s, o, u];
}
function zt(t, e, n, r, i, s) {
  const o = i.slice(0, i.length - 1), u = i[i.length - 1], [a, d, c] = ao(t, e, n, r, o), f = uo(t, e, a, d, u, s);
  return c.concat([f]);
}
function co(t, e) {
  return e ? [e].concat(t) : t;
}
function fo([t, e]) {
  return t === "or" && Array.isArray(e);
}
function lo([t, e]) {
  return t === "and" && Array.isArray(e);
}
function ho(t, e, n) {
  return (r, i) => {
    const s = t(r, i);
    return e == s ? s : `${s}-${n}`;
  };
}
function Jn(t, e, n, r, i, s) {
  const o = t(r, i), u = s.map((a, d) => {
    const c = ho(t, o, d);
    return Qr(c, n, r, i, a);
  });
  return { [e]: { patterns: u, joinSym: o } };
}
function po(t) {
  const e = [];
  for (let n = 1; n <= t.length; n++)
    e.push(t.slice(0, n));
  return e;
}
function Zn(t, e, n, r, i) {
  return po(i).map((s) => zt(t, e, n, r, s, { $isNull: !0 }));
}
function Qr(t, e, n, r, i) {
  return Object.entries(i).flatMap(([s, o]) => {
    if (fo([s, o]))
      return Jn(t, "or", e, n, r, o);
    if (lo([s, o]))
      return Jn(t, "and", e, n, r, o);
    if (s === "$entityIdStartsWith")
      return [];
    const u = s.split(".");
    if (o != null && o.hasOwnProperty("$ne") && (o = Object.assign(Object.assign({}, o), { $not: o.$ne }), delete o.$ne), o != null && o.hasOwnProperty("$not")) {
      const a = zt(t, e, n, r, u, o), d = Zn(t, e, n, r, u);
      return [
        {
          or: {
            patterns: [a, ...d],
            joinSym: t(n, r)
          }
        }
      ];
    }
    return o != null && o.hasOwnProperty("$isNull") && o.$isNull === !0 && u.length > 1 ? [
      {
        or: {
          patterns: Zn(t, e, n, r, u),
          joinSym: t(n, r)
        }
      }
    ] : zt(t, e, n, r, u, o);
  });
}
function yo(t, e, n, r) {
  const i = yt;
  return r ? Qr(i, t, e, n, r).concat(Hn(i, t, e, n)) : Hn(i, t, e, n);
}
function bo(t, e, n) {
  return [t(e, n), t("time", n)];
}
function _o(t, e, n, r, i, s) {
  const [o, u, a, d, c] = Gr(t, e, n, r, i), f = so(a, t(n, r), s);
  return [o, u, f, d, c];
}
function go(t, e, { etype: n, level: r, form: i }, s) {
  const o = Object.keys(i).filter((u) => u !== "$");
  return o.length ? Object.entries(s).map(function([a, d]) {
    return o.map(function(l) {
      var p, y, b;
      const g = !!(e.cardinalityInference && (!((b = (y = (p = e.linkIndex) === null || p === void 0 ? void 0 : p[n]) === null || y === void 0 ? void 0 : y[l]) === null || b === void 0) && b.isSingular));
      try {
        const [m, T, v] = _o(t, e, n, r, l, a), k = Yr(e, {
          etype: m,
          level: T,
          form: i[l],
          join: v
        }), S = g ? k[0] : k;
        return { [l]: S };
      } catch (m) {
        if (m instanceof Ae)
          return { [l]: g ? void 0 : [] };
        throw m;
      }
    }).reduce(function(l, p) {
      return Object.assign(Object.assign({}, l), p);
    }, d);
  }) : Object.values(s);
}
function To(t, e, n) {
  return n === "string" ? to(t, e) : t > e ? 1 : -1;
}
function Fe(t, e, n, r, i) {
  return e === r || e == null && r == null ? Zs(t, n) : r == null ? 1 : e == null ? -1 : To(e, r, i);
}
function lt([t, e], [n, r], i) {
  return Fe(t, e, n, r, i);
}
function Vt(t) {
  return t == null ? t : new Date(t).getTime();
}
function mo(t, e, n, r) {
  var i;
  const [s, o, u, a] = t, d = n === "desc" ? 1 : -1;
  if (((i = e["forward-identity"]) === null || i === void 0 ? void 0 : i[2]) === "id")
    return lt(r, [s, a], null) === d;
  const [c, f] = r, l = e["checked-data-type"], p = l === "date" ? Vt(f) : f, y = l === "date" ? Vt(u) : u;
  return lt([c, p], [s, y], l) === d;
}
function wo(t, e) {
  const n = e[1];
  return t.attrs[n];
}
function vo(t, e, n) {
  const r = Object.keys(n)[0];
  return fe(t, e, r);
}
function So(t, e, n, r) {
  if (n)
    return wo(t, n);
  if (r)
    return vo(t, e, r);
}
function Oo(t, e, n) {
  var r, i;
  if (!Array.isArray(n.fields))
    return Ms(t, e);
  const s = /* @__PURE__ */ new Map();
  for (const o of n.fields) {
    const u = fe(t, e, o), a = (r = u == null ? void 0 : u["forward-identity"]) === null || r === void 0 ? void 0 : r[2];
    a && cn(u) && s.set(a, u);
  }
  if (!s.has("id")) {
    const o = fe(t, e, "id"), u = (i = o == null ? void 0 : o["forward-identity"]) === null || i === void 0 ? void 0 : i[2];
    u && s.set(u, o);
  }
  return s;
}
function Eo(t, { etype: e, pageInfo: n, dq: r, form: i }) {
  var s, o;
  const u = (s = i == null ? void 0 : i.$) === null || s === void 0 ? void 0 : s.order, a = Hr(i), d = Ao(i);
  let c = zs(t, r);
  const f = n == null ? void 0 : n["start-cursor"], l = So(t, e, f, u);
  if (l && ((o = l == null ? void 0 : l["forward-identity"]) === null || o === void 0 ? void 0 : o[2]) !== "id") {
    const b = l["checked-data-type"] === "date", g = l.id;
    c = c.map(([m]) => {
      var T, v, k, S, I;
      let R = (I = (S = (k = (v = (T = t.eav.get(m)) === null || T === void 0 ? void 0 : T.get(g)) === null || v === void 0 ? void 0 : v.values()) === null || k === void 0 ? void 0 : k.next()) === null || S === void 0 ? void 0 : S.value) === null || I === void 0 ? void 0 : I[2];
      return b && (R = Vt(R)), [m, R];
    });
  }
  c.sort(d === "asc" ? function(g, m) {
    return lt(g, m, l == null ? void 0 : l["checked-data-type"]);
  } : function(g, m) {
    return lt(m, g, l == null ? void 0 : l["checked-data-type"]);
  });
  let p = {};
  const y = Oo(t, e, r);
  for (const b of c) {
    const [g] = b;
    if (p[g] || !a && f && l && mo(f, l, d, b))
      continue;
    const m = Is(t, y, g);
    m && (p[g] = m);
  }
  return p;
}
function Ao(t) {
  var e;
  const n = (e = t.$) === null || e === void 0 ? void 0 : e.order;
  return n && n[Object.keys(n)[0]] || "asc";
}
function Hr(t) {
  var e, n, r;
  const i = (e = t.$) === null || e === void 0 ? void 0 : e.offset, s = (n = t.$) === null || n === void 0 ? void 0 : n.before, o = (r = t.$) === null || r === void 0 ? void 0 : r.after;
  return !i && !s && !o;
}
function jo(t, { etype: e, level: n, form: r, join: i, pageInfo: s }) {
  var o, u, a, d, c;
  if (!Hr(r) && (!s || !s["start-cursor"]))
    return [];
  const f = co(yo(t, e, n, (o = r.$) === null || o === void 0 ? void 0 : o.where), i), l = bo(yt, e, n), p = (u = r.$) === null || u === void 0 ? void 0 : u.fields, y = Eo(t, {
    etype: e,
    pageInfo: s,
    form: r,
    dq: { where: f, find: l, fields: p }
  }), b = ((a = r.$) === null || a === void 0 ? void 0 : a.limit) || ((d = r.$) === null || d === void 0 ? void 0 : d.first) || ((c = r.$) === null || c === void 0 ? void 0 : c.last);
  if (b != null) {
    n > 0 && console.warn("WARNING: Limits in child queries are only run client-side. Data returned from the server will not have a limit.");
    const g = Object.entries(y);
    return g.length <= b ? y : Object.fromEntries(g.slice(0, b));
  }
  return y;
}
function ko(t, e) {
  try {
    return jo(t, e);
  } catch (n) {
    if (n instanceof Ae)
      return {};
    throw n;
  }
}
function Yr(t, e) {
  const n = ko(t, e);
  return go(yt, t, e, n);
}
function Co(t) {
  const e = {};
  for (const [n, r] of Object.entries(t))
    e[n] = {
      startCursor: r["start-cursor"],
      endCursor: r["end-cursor"],
      hasNextPage: r["has-next-page?"],
      hasPreviousPage: r["has-previous-page?"]
    };
  return e;
}
function Jr({ store: t, pageInfo: e, aggregate: n }, r) {
  const s = { data: Object.keys(r).reduce(function(u, a) {
    return n != null && n[a] || a === "$$ruleParams" || (u[a] = Yr(t, {
      etype: a,
      form: r[a],
      level: 0,
      pageInfo: e == null ? void 0 : e[a]
    })), u;
  }, {}) };
  return e && (s.pageInfo = Co(e)), n && (s.aggregate = n), s;
}
function Po() {
  const e = {
    __etype: 1,
    __ops: 1,
    create: 1,
    update: 1,
    link: 1,
    unlink: 1,
    delete: 1,
    merge: 1,
    ruleParams: 1
  };
  return new Set(Object.keys(e));
}
const Io = Po();
function Wt(t, e, n) {
  const r = {
    __etype: t,
    __ops: n
  };
  return new Proxy(r, {
    get: (i, s) => {
      if (s === "__ops")
        return n;
      if (s === "__etype")
        return t;
      if (Io.has(s))
        return (o, u) => Wt(t, e, [
          ...n,
          u ? [s, t, e, o, u] : [s, t, e, o]
        ]);
    }
  });
}
function ht(t) {
  return t.startsWith("lookup__");
}
function Zr(t) {
  const [e, n, ...r] = t.split("__");
  return [n, JSON.parse(r.join("__"))];
}
function Mo(t) {
  return new Proxy({
    __etype: t
  }, {
    get(e, n) {
      if (n === "__etype")
        return t;
      const r = n;
      return ht(r) ? Wt(t, Zr(r), []) : Wt(t, r, []);
    }
  });
}
function ln() {
  return new Proxy({}, {
    get(t, e) {
      return Mo(e);
    }
  });
}
ln();
function Ro(t) {
  return t.__ops;
}
function $o(t, e) {
  const { attrIdMap: n, refSwapAttrIds: r } = t, i = [];
  for (const o of e) {
    const u = n[o];
    if (u)
      i.push(u);
    else if (Array.isArray(o) && o.length == 2 && n[o[0]]) {
      const [a, d] = o;
      i.push([n[a], d]);
    } else
      i.push(o);
  }
  const [s] = e;
  if ((s === "add-triple" || s === "retract-triple") && r.has(e[2])) {
    const o = i[1];
    i[1] = i[3], i[3] = o;
  }
  return i;
}
function K(t, e, n) {
  return Object.values(t).find((r) => {
    const [i, s, o] = r["forward-identity"];
    return s === e && o === n;
  });
}
function _e(t, e, n) {
  return Object.values(t).find((r) => {
    const i = r["reverse-identity"];
    if (!i)
      return !1;
    const [s, o, u] = i;
    return o === e && u === n;
  });
}
function xo(t) {
  if (Array.isArray(t))
    return t;
  const e = Object.entries(t);
  if (e.length !== 1)
    throw new Error("lookup must be an object with a single unique attr and value.");
  return e[0];
}
function Bt(t, e, n) {
  return n.indexOf(".") !== -1 && // attr names can have `.` in them, so use the attr we find with a `.`
  // before assuming it's a ref lookup.
  !K(t, e, n);
}
function Gt(t) {
  const [e, n, ...r] = t.split(".");
  if (r.length > 0 || n !== "id")
    throw new Error(`${t} is not a valid lookup attribute.`);
  return e;
}
function Do(t, e, n) {
  if (!Bt(t, e, n))
    return K(t, e, n);
  const r = Gt(n), i = K(t, e, r) || _e(t, e, r);
  if (i && i["value-type"] !== "ref")
    throw new Error(`${n} does not reference a valid link attribute.`);
  return i;
}
function Qt(t) {
  return typeof t == "string" && !ht(t) ? null : typeof t == "string" && ht(t) ? Zr(t) : xo(t);
}
function Q(t, e, n) {
  const r = Qt(n);
  if (r === null)
    return n;
  const [i, s] = r, o = Do(t, e, i);
  if (!o || !o["unique?"])
    throw new Error(`${i} is not a unique attribute.`);
  return [o.id, s];
}
function Xr(t, e, n, r) {
  const i = Q(t, e, n);
  return Array.isArray(i) ? [[
    "add-triple",
    i,
    K(t, e, "id").id,
    i
  ]].concat(r) : r;
}
function Uo({ attrs: t }, [e, n, r]) {
  const i = Object.entries(r).flatMap(([s, o]) => {
    const u = Array.isArray(o) ? o : [o], a = K(t, e, s), d = _e(t, e, s);
    return u.map((c) => a ? [
      "add-triple",
      Q(t, e, n),
      a.id,
      Q(t, a["reverse-identity"][1], c)
    ] : [
      "add-triple",
      Q(t, d["forward-identity"][1], c),
      d.id,
      Q(t, e, n)
    ]);
  });
  return Xr(t, e, n, i);
}
function Lo({ attrs: t }, [e, n, r]) {
  const i = Object.entries(r).flatMap(([s, o]) => {
    const u = Array.isArray(o) ? o : [o], a = K(t, e, s), d = _e(t, e, s);
    return u.map((c) => a ? [
      "retract-triple",
      Q(t, e, n),
      a.id,
      Q(t, a["reverse-identity"][1], c)
    ] : [
      "retract-triple",
      Q(t, d["forward-identity"][1], c),
      d.id,
      Q(t, e, n)
    ]);
  });
  return Xr(t, e, n, i);
}
function Fo(t, e, n) {
  if (Array.isArray(n)) {
    const [r, i] = n;
    for (const s of t || []) {
      const o = s == null ? void 0 : s.aev.get(r);
      if (o) {
        for (const [u, a, d] of G(o, 2))
          if (d === i)
            return !0;
      }
    }
  } else
    for (const r of t || []) {
      const i = r == null ? void 0 : r.eav.get(n);
      if (i) {
        for (const s of i.keys())
          if (r.attrs[s]["forward-identity"][1] == e)
            return !0;
      }
    }
  return !1;
}
function ei({ stores: t, attrs: e }, [n, r, i, s]) {
  return (s == null ? void 0 : s.upsert) === !1 ? { mode: "update" } : (s == null ? void 0 : s.upsert) === !0 ? null : Fo(t, n, r) ? { mode: "update" } : null;
}
function No(t, e) {
  const { stores: n, attrs: r } = t, [i, s, o, u] = e, a = un(o), d = Q(r, i, s);
  return [["id", d]].concat(Object.entries(a)).map(([f, l]) => {
    const p = K(r, i, f);
    return p["checked-data-type"] === "date" && t.useDateObjects && (l = pt(l)), ["add-triple", d, p.id, l, { mode: "create" }];
  });
}
function Ko(t, e) {
  const { stores: n, attrs: r } = t, [i, s, o, u] = e, a = un(o), d = Q(r, i, s), c = ei(t, [i, d, o, u]);
  return [["id", d]].concat(Object.entries(a)).map(([l, p]) => {
    const y = K(r, i, l);
    return y["checked-data-type"] === "date" && t.useDateObjects && (p = pt(p)), [
      "add-triple",
      d,
      y.id,
      p,
      ...c ? [c] : []
    ];
  });
}
function qo({ attrs: t }, [e, n]) {
  return [["delete-entity", Q(t, e, n), e]];
}
function zo(t, e) {
  const { stores: n, attrs: r } = t, [i, s, o, u] = e, a = un(o), d = Q(r, i, s), c = ei(t, [i, d, o, u]), f = Object.entries(a).map(([p, y]) => {
    const b = K(r, i, p);
    return [
      "deep-merge-triple",
      d,
      b.id,
      y,
      ...c ? [c] : []
    ];
  });
  return [[
    "add-triple",
    d,
    K(r, i, "id").id,
    d,
    ...c ? [c] : []
  ]].concat(f);
}
function Vo({ attrs: t }, [e, n, r]) {
  return [["rule-params", Q(t, e, n), e, r]];
}
function Wo(t) {
  const [e, n, r, i, s] = t;
  if (!i)
    return t;
  const o = Object.assign({}, i);
  return delete o.id, [e, n, r, o, ...s ? [s] : []];
}
function Bo(t, e) {
  const [n, ...r] = Wo(e);
  switch (n) {
    case "merge":
      return zo(t, r);
    case "create":
      return No(t, r);
    case "update":
      return Ko(t, r);
    case "link":
      return Uo(t, r);
    case "unlink":
      return Lo(t, r);
    case "delete":
      return qo(t, r);
    case "ruleParams":
      return Vo(t, r);
    default:
      throw new Error(`unsupported action ${n}`);
  }
}
function Go(t) {
  switch (t) {
    case "string":
    case "date":
    case "boolean":
    case "number":
      return t;
    default:
      return;
  }
}
function Qo(t, e, n) {
  var r, i;
  const s = (i = (r = t.entities[e]) === null || r === void 0 ? void 0 : r.attrs) === null || i === void 0 ? void 0 : i[n];
  if (n === "id")
    return null;
  if (!s)
    throw new Error(`${e}.${n} does not exist in your schema`);
  const { unique: o, indexed: u } = s == null ? void 0 : s.config, a = Go(s == null ? void 0 : s.valueType);
  return {
    "index?": u,
    "unique?": o,
    "checked-data-type": a
  };
}
function nt(t, e, n, r) {
  const i = t ? Qo(t, e, n) : null, s = L(), u = [L(), e, n];
  return Object.assign(Object.assign({ id: s, "forward-identity": u, "value-type": "blob", cardinality: "one", "unique?": !1, "index?": !1, isUnsynced: !0 }, i || {}), r || {});
}
function Ho(t, e, n) {
  return Object.values(t.links).find((i) => i.forward.on === e && i.forward.label === n || i.reverse.on === e && i.reverse.label === n);
}
function Yo(t, e, n) {
  const r = Ho(t, e, n);
  if (!r)
    throw new Error(`Couldn't find the link ${e}.${n} in your schema`);
  const { forward: i, reverse: s } = r;
  return {
    "forward-identity": [L(), i.on, i.label],
    "reverse-identity": [L(), s.on, s.label],
    cardinality: i.has === "one" ? "one" : "many",
    "unique?": s.has === "one",
    "on-delete": i.onDelete,
    "on-delete-reverse": s.onDelete
  };
}
function Xn(t, e, n, r) {
  const i = t ? Yo(t, e, n) : null, s = L(), o = [L(), e, n], u = [L(), n, e];
  return Object.assign(Object.assign({ id: s, "forward-identity": o, "reverse-identity": u, "value-type": "ref", cardinality: "many", "unique?": !1, "index?": !1, isUnsynced: !0 }, i || {}), r || {});
}
const Jo = /* @__PURE__ */ new Set(["create", "update", "merge", "link", "unlink"]), Zo = /* @__PURE__ */ new Set(["link", "unlink"]), Xo = /* @__PURE__ */ new Set(["create", "update", "merge"]), eu = /* @__PURE__ */ new Set([
  "link",
  "unlink",
  "create",
  "update",
  "merge",
  "delete",
  "ruleParams"
]), Ht = { "unique?": !0, "index?": !0 }, tu = Object.assign(Object.assign({}, Ht), { cardinality: "one" });
function nu(t) {
  const e = [], [n, r, i, s] = t;
  if (!eu.has(n))
    return e;
  const o = Qt(i);
  if (o && e.push({ etype: r, lookupPair: o }), n === "link")
    for (const [u, a] of Object.entries(s)) {
      const d = Array.isArray(a) ? a : [a];
      for (const c of d) {
        const f = Qt(c);
        f && e.push({
          etype: r,
          lookupPair: f,
          linkLabel: u
        });
      }
    }
  return e;
}
function ru({ attrs: t, schema: e }, n) {
  var r, i;
  const [s, o, u] = [/* @__PURE__ */ new Set(), Object.assign({}, t), []];
  function a(f) {
    o[f.id] = f, u.push(["add-attr", f]), s.add(f.id);
  }
  function d(f) {
    f != null && f.isUnsynced && !s.has(f.id) && (u.push(["add-attr", f]), s.add(f.id));
  }
  function c(f, l) {
    const p = K(o, f, l), y = _e(o, f, l);
    d(p), d(y), !p && !y && a(Xn(e, f, l, tu));
  }
  for (const f of n)
    for (const { etype: l, lookupPair: p, linkLabel: y } of nu(f)) {
      const b = p[0];
      if (y) {
        c(l, y);
        const g = K(o, l, y), m = _e(o, l, y);
        d(g), d(m);
        const T = ((r = g == null ? void 0 : g["reverse-identity"]) === null || r === void 0 ? void 0 : r[1]) || ((i = m == null ? void 0 : m["forward-identity"]) === null || i === void 0 ? void 0 : i[1]) || y;
        if (Bt(o, T, b))
          c(T, Gt(b));
        else {
          const v = K(o, T, b);
          v || a(nt(e, T, b, Ht)), d(v);
        }
      } else if (Bt(o, l, b))
        c(l, Gt(b));
      else {
        const g = K(o, l, b);
        g || a(nt(e, l, b, Ht)), d(g);
      }
    }
  for (const f of n) {
    const [l, p, y, b] = f;
    if (Jo.has(l)) {
      const g = K(o, p, "id");
      d(g), g || a(nt(e, p, "id", { "unique?": !0 }));
      for (const m of Object.keys(b)) {
        const T = K(o, p, m);
        if (d(T), Xo.has(l) && (T || a(nt(e, p, m, m === "id" ? { "unique?": !0 } : null))), Zo.has(l)) {
          const v = _e(o, p, m);
          !T && !v && a(Xn(e, p, m)), d(v);
        }
      }
    }
  }
  return [o, u];
}
function iu(t, e) {
  const r = (Array.isArray(e) ? e : [e]).flatMap((a) => Ro(a)), [i, s] = ru(t, r), o = Object.assign(Object.assign({}, t), { attrs: i }), u = r.flatMap((a) => Bo(o, a));
  return [...s, ...u];
}
var re = function(t, e, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function u(c) {
      try {
        d(r.next(c));
      } catch (f) {
        o(f);
      }
    }
    function a(c) {
      try {
        d(r.throw(c));
      } catch (f) {
        o(f);
      }
    }
    function d(c) {
      c.done ? s(c.value) : i(c.value).then(u, a);
    }
    d((r = r.apply(t, e || [])).next());
  });
};
function er(t, e) {
  typeof requestIdleCallback > "u" ? t() : requestIdleCallback(t, { timeout: e });
}
const qe = "__meta";
class su {
  constructor(e, n) {
  }
}
class Yt {
  constructor(e) {
    var n, r;
    this._subs = [], this._nextSave = null, this._nextGc = null, this._pendingSaveKeys = /* @__PURE__ */ new Set(), this._loadedKeys = /* @__PURE__ */ new Set(), this._version = 0, this._meta = {
      isLoading: !0,
      onLoadCbs: [],
      value: null,
      error: null,
      attempts: 0
    }, this._persister = e.persister, this._merge = e.merge, this.serialize = e.serialize, this.parse = e.parse, this._objectSize = e.objectSize, this._log = e.logger, this._saveThrottleMs = (n = e.saveThrottleMs) !== null && n !== void 0 ? n : 100, this._idleCallbackMaxWaitMs = (r = e.idleCallbackMaxWaitMs) !== null && r !== void 0 ? r : 1e3, this._gcOpts = e.gc, this.currentValue = {}, this._loadedKeys = /* @__PURE__ */ new Set(), this._loadingKeys = {}, this._initMeta(), e.preloadEntryCount && this._preloadEntries(e.preloadEntryCount);
  }
  _initMeta() {
    return re(this, void 0, void 0, function* () {
      var e, n, r;
      this._meta.loadingPromise && (yield this._meta.loadingPromise);
      try {
        const i = this._persister.getItem(qe);
        this._meta.loadingPromise = i;
        const s = yield i;
        this._meta.isLoading = !1, this._meta.error = null, this._meta.loadingPromise = null, this._meta.attempts = 0;
        const o = (n = (e = this._meta.value) === null || e === void 0 ? void 0 : e.objects) !== null && n !== void 0 ? n : {}, u = s ?? {}, a = (r = u.objects) !== null && r !== void 0 ? r : {};
        this._meta.value = Object.assign(Object.assign({}, u), { objects: Object.assign(Object.assign({}, o), a) });
      } catch (i) {
        this._meta.error = i, this._meta.attempts++, this._meta.loadingPromise = null;
      }
    });
  }
  _getMeta() {
    return re(this, void 0, void 0, function* () {
      return this._meta.value ? this._meta.value : this._meta.loadingPromise ? (yield this._meta.loadingPromise, this._meta.value) : (this._initMeta(), yield this._meta.loadingPromise, this._meta.value);
    });
  }
  _refreshMeta() {
    return re(this, void 0, void 0, function* () {
      return yield this._initMeta(), this._meta.value;
    });
  }
  _preloadEntries(e) {
    return re(this, void 0, void 0, function* () {
      const n = yield this.waitForMetaToLoad();
      if (!n)
        return;
      const r = Object.entries(n.objects);
      r.sort(([i, s], [o, u]) => u.updatedAt - s.updatedAt);
      for (const [i] of r.slice(0, e))
        this._loadKey(i);
    });
  }
  _getFromStorage(e) {
    return re(this, void 0, void 0, function* () {
      try {
        const n = yield this._persister.getItem(e);
        return n && this.parse(e, n);
      } catch (n) {
        return console.error(`Unable to read from storage for key=${e}`, n), null;
      }
    });
  }
  waitForKeyToLoad(e) {
    return re(this, void 0, void 0, function* () {
      return this._loadedKeys.has(e) ? this.currentValue[e] : (yield this._loadingKeys[e] || this._loadKey(e), this.currentValue[e]);
    });
  }
  // Used for tests
  waitForMetaToLoad() {
    return re(this, void 0, void 0, function* () {
      return this._getMeta();
    });
  }
  // Unloads the key so that it can be garbage collected, but does not
  // delete it. Removes the key from currentValue.
  unloadKey(e) {
    this._loadedKeys.delete(e), delete this._loadingKeys[e], delete this.currentValue[e];
  }
  _loadKey(e) {
    return re(this, void 0, void 0, function* () {
      if (this._loadedKeys.has(e) || e in this._loadingKeys)
        return;
      const n = this._getFromStorage(e);
      this._loadingKeys[e] = n;
      const r = yield n;
      if (delete this._loadingKeys[e], this._loadedKeys.add(e), r) {
        const i = this._merge(e, r, this.currentValue[e]);
        i && (this.currentValue[e] = i);
      }
      this.onKeyLoaded && this.onKeyLoaded(e);
    });
  }
  // Returns a promise with a number so that we can wait for flush
  // to finish in the tests. The number is the number of operations
  // it performed, but it's mostly there so that typescript will warn
  // us if we forget to retun the promise from the function.
  _writeToStorage(e) {
    var n, r;
    const i = [], s = e == null ? void 0 : e.skipGc;
    if (this._meta.isLoading) {
      const p = new Promise((y, b) => {
        var g;
        setTimeout(() => this._enqueuePersist(e ? Object.assign(Object.assign({}, e), { attempts: (e.attempts || 0) + 1 }) : { attempts: 1 }).then(y).catch(b), 10 + ((g = e == null ? void 0 : e.attempts) !== null && g !== void 0 ? g : 0) * 1e3);
      });
      return i.push(p), Promise.all(i).then((y) => y.reduce((b, g) => b + g, 0));
    }
    const o = this._meta.value;
    if (!o)
      return Promise.resolve(0);
    const u = [], a = [];
    for (const p of this._pendingSaveKeys)
      p in this.currentValue ? a.push(p) : (u.push(p), delete o.objects[p]);
    for (const p of u) {
      const y = this._persister.removeItem(p);
      i.push(y.then(() => 1)), this._loadedKeys.delete(p), this._pendingSaveKeys.delete(p);
    }
    const d = [], c = [[qe, o]], f = (n = o.objects) !== null && n !== void 0 ? n : {};
    o.objects = f;
    for (const p of a)
      if (this._loadedKeys.has(p)) {
        const y = this.serialize(p, this.currentValue[p]);
        c.push([p, y]);
        const b = this._objectSize(y), g = (r = f[p]) !== null && r !== void 0 ? r : {
          createdAt: Date.now(),
          updatedAt: Date.now(),
          size: b
        };
        g.updatedAt = Date.now(), g.size = b, f[p] = g, this._pendingSaveKeys.delete(p);
      } else
        d.push(p);
    const l = this._persister.multiSet(c);
    i.push(l.then(() => 1));
    for (const p of d) {
      const y = this._loadKey(p).then(() => this._enqueuePersist(e));
      i.push(y);
    }
    return s || this.gc(), Promise.all(i).then((p) => p.reduce((y, b) => y + b, 0));
  }
  flush() {
    return re(this, void 0, void 0, function* () {
      return this._nextSave ? (clearTimeout(this._nextSave), this._nextSave = null, this._writeToStorage()) : void 0;
    });
  }
  _gc() {
    return re(this, void 0, void 0, function* () {
      if (!this._gcOpts)
        return;
      const e = new Set(yield this._persister.getAllKeys());
      e.delete(qe);
      const n = new Set(Object.keys(this.currentValue));
      for (const l of Object.keys(this._loadingKeys))
        n.add(l);
      for (const l of this._loadedKeys)
        n.add(l);
      const r = yield this._refreshMeta();
      if (!r) {
        this._log.info("Could not gc because we were not able to load meta");
        return;
      }
      const i = [], s = {
        gcOpts: this._gcOpts,
        keys: e,
        sacredKeys: n,
        removed: [],
        metaRemoved: [],
        removedMissingCount: 0,
        removedOldCount: 0,
        removedThresholdCount: 0,
        removedSizeCount: 0
      };
      for (const l of e)
        n.has(l) || l in r.objects || (this._log.info("Lost track of key in meta", l), i.push(this._persister.removeItem(l)), s.removed.push(l), s.removedMissingCount++);
      const o = Date.now();
      for (const [l, p] of Object.entries(r.objects))
        !n.has(l) && p.updatedAt < o - this._gcOpts.maxAgeMs && (i.push(this._persister.removeItem(l)), delete r.objects[l], s.removed.push(l), s.removedOldCount++);
      const u = Object.entries(r.objects);
      u.sort(([l, p], [y, b]) => p.updatedAt - b.updatedAt);
      const a = u.filter(([l]) => !n.has(l));
      if (u.length > this._gcOpts.maxEntries)
        for (const [l] of a.slice(0, u.length - this._gcOpts.maxEntries))
          i.push(this._persister.removeItem(l)), delete r.objects[l], s.removed.push(l), s.removedThresholdCount++;
      const d = Object.entries(r.objects);
      d.sort(([l, p], [y, b]) => p.updatedAt - b.updatedAt);
      const c = d.filter(([l]) => !n.has(l));
      let f = d.reduce((l, [p, y]) => l + y.size, 0);
      for (; f > 0 && f > this._gcOpts.maxSize && c.length; ) {
        const [[l, p]] = c.splice(0, 1);
        f -= p.size, i.push(this._persister.removeItem(l)), delete r.objects[l], s.removed.push(l), s.removedSizeCount++;
      }
      for (const l of Object.keys(r.objects))
        !e.has(l) && !n.has(l) && delete r.objects[l];
      return (s.removed.length || s.metaRemoved.length) && i.push(this._enqueuePersist({ skipGc: !0 })), this._log.info("Completed GC", s), yield Promise.all(i), s;
    });
  }
  // Schedules a GC to run in one minute (unless it is already scheduled)
  gc() {
    this._nextGc || (this._nextGc = setTimeout(
      () => {
        er(() => {
          this._nextGc = null, this._gc();
        }, 30 * 1e3);
      },
      // 1 minute + some jitter to keep multiple tabs from running at same time
      1e3 * 60 + Math.random() * 500
    ));
  }
  _enqueuePersist(e) {
    return new Promise((n, r) => {
      if (this._nextSave) {
        n(0);
        return;
      }
      this._nextSave = setTimeout(() => {
        er(() => {
          this._nextSave = null, this._writeToStorage(e).then(n).catch(r);
        }, this._idleCallbackMaxWaitMs);
      }, this._saveThrottleMs);
    });
  }
  version() {
    return this._version;
  }
  // Takes a function that updates the store in place.
  // Uses `mutative` to get a list of keys that were changed
  // so that we know which entries we need to persist to the store.
  updateInPlace(e) {
    this._version++;
    const [n, r] = ft(this.currentValue, e, {
      enablePatches: !0
    });
    for (const i of r) {
      const s = i.path[0];
      s && typeof s == "string" && (this._pendingSaveKeys.add(s), this._loadedKeys.has(s) || this._loadKey(s));
    }
    this.currentValue = n, this._enqueuePersist();
    for (const i of this._subs)
      i(this.currentValue);
    return n;
  }
  subscribe(e) {
    return this._subs.push(e), e(this.currentValue), () => {
      this._subs = this._subs.filter((n) => n !== e);
    };
  }
}
var oe = function(t, e, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function u(c) {
      try {
        d(r.next(c));
      } catch (f) {
        o(f);
      }
    }
    function a(c) {
      try {
        d(r.throw(c));
      } catch (f) {
        o(f);
      }
    }
    function d(c) {
      c.done ? s(c.value) : i(c.value).then(u, a);
    }
    d((r = r.apply(t, e || [])).next());
  });
};
const ou = 6, uu = ["kv", "querySubs", "syncSubs"];
function au(t) {
  return function(n) {
    console.error("Error in IndexedDB event", { source: t, event: n });
  };
}
function cu(t) {
  return oe(this, void 0, void 0, function* () {
    return new Promise((e) => {
      const n = indexedDB.open(t);
      n.onerror = (r) => {
        e(null);
      }, n.onsuccess = (r) => {
        const s = r.target.result;
        e(s);
      }, n.onupgradeneeded = (r) => {
        var i;
        (i = r.target.transaction) === null || i === void 0 || i.abort(), e(null);
      };
    });
  });
}
function du(t, e, n) {
  return oe(this, void 0, void 0, function* () {
    const r = (
      // Backwards compatibility for older versions where we JSON.stringified before storing
      typeof e == "string" ? JSON.parse(e) : e
    );
    if (!r)
      return;
    const i = /* @__PURE__ */ new Set();
    return new Promise((s, o) => {
      var u, a, d, c;
      const f = {};
      for (const [y, b] of Object.entries(r)) {
        const g = typeof b == "string" ? JSON.parse(b) : b;
        if (g.lastAccessed) {
          const T = {
            createdAt: g.lastAccessed,
            updatedAt: g.lastAccessed,
            size: (c = (d = (a = (u = g.result) === null || u === void 0 ? void 0 : u.store) === null || a === void 0 ? void 0 : a.triples) === null || d === void 0 ? void 0 : d.length) !== null && c !== void 0 ? c : 0
          };
          f[y] = T;
        }
        const m = n.put(g, y);
        i.add(m);
      }
      const l = { objects: f }, p = n.put(l, qe);
      i.add(p);
      for (const y of i)
        y.onsuccess = () => {
          i.delete(y), i.size === 0 && s();
        }, y.onerror = (b) => {
          o(b);
        };
    });
  });
}
function tr(t, e, n) {
  return oe(this, void 0, void 0, function* () {
    const r = n.put(e, t);
    return new Promise((i, s) => {
      r.onsuccess = () => i(), r.onerror = (o) => s(o);
    });
  });
}
function fu(t, e) {
  return oe(this, void 0, void 0, function* () {
    const n = yield cu(`instant_${t}_5`);
    if (!n)
      return;
    const r = yield new Promise((c, f) => {
      const y = n.transaction(["kv"], "readonly").objectStore("kv").openCursor();
      y.onerror = (g) => {
        f(g);
      };
      const b = [];
      y.onsuccess = () => {
        const g = y.result;
        if (g) {
          const m = g.key, T = g.value;
          b.push([m, T]), g.continue();
        } else
          c(b);
      }, y.onerror = (g) => {
        f(g);
      };
    }), i = e.transaction(["kv", "querySubs"], "readwrite"), s = i.objectStore("kv"), o = i.objectStore("querySubs"), u = [], a = { objects: {} };
    for (const [c, f] of r)
      switch (c) {
        case "querySubs": {
          const l = du(c, f, o);
          u.push(l);
          break;
        }
        default: {
          const l = tr(c, f, s);
          u.push(l);
          const p = {
            createdAt: Date.now(),
            updatedAt: Date.now(),
            size: 0
          };
          a.objects[c] = p;
          break;
        }
      }
    const d = tr(qe, a, s);
    u.push(d), yield Promise.all(u), yield new Promise((c, f) => {
      i.oncomplete = (l) => c(l), i.onerror = (l) => f(l), i.onabort = (l) => f(l);
    });
  });
}
const nr = /* @__PURE__ */ new Map();
class ti extends su {
  constructor(e, n) {
    super(e, n), this.dbName = `instant_${e}_${ou}`, this._storeName = n, this._appId = e, this._dbPromise = this._init();
  }
  _init() {
    return new Promise((e, n) => {
      let r = !1;
      const i = indexedDB.open(this.dbName, 1);
      i.onerror = (s) => {
        n(s);
      }, i.onsuccess = (s) => {
        const u = s.target.result;
        if (r) {
          const a = fu(this._appId, u).catch((d) => {
            au("Error upgrading store from version 5 to 6.")(d);
          });
          nr.set(this.dbName, a), a.then(() => e(u)).catch(() => e(u));
        } else {
          const a = nr.get(this.dbName);
          a ? a.then(() => e(u)).catch(() => e(u)) : e(u);
        }
      }, i.onupgradeneeded = (s) => {
        r = !0, this._upgradeStore(s);
      };
    });
  }
  _upgradeStore(e) {
    const r = e.target.result;
    for (const i of uu)
      r.objectStoreNames.contains(i) || r.createObjectStore(i);
  }
  getItem(e) {
    return oe(this, void 0, void 0, function* () {
      const n = yield this._dbPromise;
      return new Promise((r, i) => {
        const u = n.transaction([this._storeName], "readonly").objectStore(this._storeName).get(e);
        u.onerror = (a) => {
          i(a);
        }, u.onsuccess = (a) => {
          u.result ? r(u.result) : r(null);
        };
      });
    });
  }
  setItem(e, n) {
    return oe(this, void 0, void 0, function* () {
      const r = yield this._dbPromise;
      return new Promise((i, s) => {
        const a = r.transaction([this._storeName], "readwrite").objectStore(this._storeName).put(n, e);
        a.onerror = (d) => {
          s(d);
        }, a.onsuccess = (d) => {
          i();
        };
      });
    });
  }
  // Performs all writes in a transaction so that all succeed or none succeed.
  multiSet(e) {
    return oe(this, void 0, void 0, function* () {
      const n = yield this._dbPromise;
      return new Promise((r, i) => {
        const s = n.transaction([this._storeName], "readwrite"), o = s.objectStore(this._storeName), u = /* @__PURE__ */ new Set();
        for (const [a, d] of e) {
          const c = o.put(d, a);
          u.add(c);
        }
        for (const a of u)
          a.onerror = (d) => {
            s.abort(), i(d);
          }, a.onsuccess = (d) => {
            u.delete(a), u.size === 0 && r();
          };
      });
    });
  }
  removeItem(e) {
    return oe(this, void 0, void 0, function* () {
      const n = yield this._dbPromise;
      return new Promise((r, i) => {
        const u = n.transaction([this._storeName], "readwrite").objectStore(this._storeName).delete(e);
        u.onerror = (a) => {
          i(a);
        }, u.onsuccess = (a) => {
          r();
        };
      });
    });
  }
  getAllKeys() {
    return oe(this, void 0, void 0, function* () {
      const e = yield this._dbPromise;
      return new Promise((n, r) => {
        const o = e.transaction([this._storeName], "readonly").objectStore(this._storeName).getAllKeys();
        o.onerror = (u) => {
          r(u);
        }, o.onsuccess = (u) => {
          n(o.result.filter((a) => typeof a == "string"));
        };
      });
    });
  }
}
var lu = function(t, e, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function u(c) {
      try {
        d(r.next(c));
      } catch (f) {
        o(f);
      }
    }
    function a(c) {
      try {
        d(r.throw(c));
      } catch (f) {
        o(f);
      }
    }
    function d(c) {
      c.done ? s(c.value) : i(c.value).then(u, a);
    }
    d((r = r.apply(t, e || [])).next());
  });
};
class ni {
  static getIsOnline() {
    return lu(this, void 0, void 0, function* () {
      return navigator.onLine;
    });
  }
  static listen(e) {
    const n = () => {
      e(!0);
    }, r = () => {
      e(!1);
    };
    return addEventListener("online", n), addEventListener("offline", r), () => {
      removeEventListener("online", n), removeEventListener("offline", r);
    };
  }
}
class je extends Error {
  constructor(e, n) {
    super(e), this.hint = n;
    const r = new.target.prototype;
    Object.setPrototypeOf && Object.setPrototypeOf(this, r), Error.captureStackTrace && Error.captureStackTrace(this, je), this.name = "InstantError";
  }
  get [Symbol.toStringTag]() {
    return "InstantError";
  }
}
var hu = function(t, e, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function u(c) {
      try {
        d(r.next(c));
      } catch (f) {
        o(f);
      }
    }
    function a(c) {
      try {
        d(r.throw(c));
      } catch (f) {
        o(f);
      }
    }
    function d(c) {
      c.done ? s(c.value) : i(c.value).then(u, a);
    }
    d((r = r.apply(t, e || [])).next());
  });
};
class bt extends je {
  constructor(e) {
    var n;
    const r = ((n = e.body) === null || n === void 0 ? void 0 : n.message) || `API Error (${e.status})`;
    super(r, e.body.hint);
    const i = new.target.prototype;
    Object.setPrototypeOf && Object.setPrototypeOf(this, i), Error.captureStackTrace && Error.captureStackTrace(this, bt), this.name = "InstantAPIError", this.status = e.status, this.body = e.body;
  }
  get [Symbol.toStringTag]() {
    return "InstantAPIError";
  }
}
function te(t, e) {
  return hu(this, void 0, void 0, function* () {
    const n = yield fetch(t, e), r = yield n.json();
    return n.status === 200 ? Promise.resolve(r) : Promise.reject(new bt({ status: n.status, body: r }));
  });
}
var Pe = function(t, e, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function u(c) {
      try {
        d(r.next(c));
      } catch (f) {
        o(f);
      }
    }
    function a(c) {
      try {
        d(r.throw(c));
      } catch (f) {
        o(f);
      }
    }
    function d(c) {
      c.done ? s(c.value) : i(c.value).then(u, a);
    }
    d((r = r.apply(t, e || [])).next());
  });
};
function pu({ apiURI: t, appId: e, email: n }) {
  return te(`${t}/runtime/auth/send_magic_code`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ "app-id": e, email: n })
  });
}
function yu(t) {
  return Pe(this, arguments, void 0, function* ({ apiURI: e, appId: n, email: r, code: i, refreshToken: s }) {
    return yield te(`${e}/runtime/auth/verify_magic_code`, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify(Object.assign({
        "app-id": n,
        email: r,
        code: i
      }, s ? { "refresh-token": s } : {}))
    });
  });
}
function bu(t) {
  return Pe(this, arguments, void 0, function* ({ apiURI: e, appId: n, refreshToken: r }) {
    return yield te(`${e}/runtime/auth/verify_refresh_token`, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({
        "app-id": n,
        "refresh-token": r
      })
    });
  });
}
function _u(t) {
  return Pe(this, arguments, void 0, function* ({ apiURI: e, appId: n }) {
    return yield te(`${e}/runtime/auth/sign_in_guest`, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({
        "app-id": n
      })
    });
  });
}
function rr(t) {
  return Pe(this, arguments, void 0, function* ({ apiURI: e, appId: n, code: r, codeVerifier: i, refreshToken: s }) {
    return yield te(`${e}/runtime/oauth/token`, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({
        app_id: n,
        code: r,
        code_verifier: i,
        refresh_token: s
      })
    });
  });
}
function gu(t) {
  return Pe(this, arguments, void 0, function* ({ apiURI: e, appId: n, nonce: r, idToken: i, clientName: s, refreshToken: o }) {
    return yield te(`${e}/runtime/oauth/id_token`, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({
        app_id: n,
        nonce: r,
        id_token: i,
        client_name: s,
        refresh_token: o
      })
    });
  });
}
function Tu(t) {
  return Pe(this, arguments, void 0, function* ({ apiURI: e, appId: n, refreshToken: r }) {
    return yield te(`${e}/runtime/signout`, {
      method: "POST",
      headers: {
        "content-type": "application/json"
      },
      body: JSON.stringify({
        app_id: n,
        refresh_token: r
      })
    });
  });
}
var Ge = function(t, e, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function u(c) {
      try {
        d(r.next(c));
      } catch (f) {
        o(f);
      }
    }
    function a(c) {
      try {
        d(r.throw(c));
      } catch (f) {
        o(f);
      }
    }
    function d(c) {
      c.done ? s(c.value) : i(c.value).then(u, a);
    }
    d((r = r.apply(t, e || [])).next());
  });
};
function mu(t) {
  return Ge(this, arguments, void 0, function* ({ apiURI: e, appId: n, path: r, file: i, refreshToken: s, contentType: o, contentDisposition: u }) {
    const a = {
      app_id: n,
      path: r,
      authorization: `Bearer ${s}`,
      "content-type": o || i.type
    };
    return u && (a["content-disposition"] = u), yield te(`${e}/storage/upload`, {
      method: "PUT",
      headers: a,
      body: i
    });
  });
}
function wu(t) {
  return Ge(this, arguments, void 0, function* ({ apiURI: e, appId: n, path: r, refreshToken: i }) {
    const { data: s } = yield te(`${e}/storage/files?app_id=${n}&filename=${encodeURIComponent(r)}`, {
      method: "DELETE",
      headers: {
        "content-type": "application/json",
        authorization: `Bearer ${i}`
      }
    });
    return s;
  });
}
function vu(t) {
  return Ge(this, arguments, void 0, function* ({ apiURI: e, appId: n, fileName: r, refreshToken: i, metadata: s = {} }) {
    const { data: o } = yield te(`${e}/storage/signed-upload-url`, {
      method: "POST",
      headers: {
        "content-type": "application/json",
        authorization: `Bearer ${i}`
      },
      body: JSON.stringify({
        app_id: n,
        filename: r
      })
    });
    return o;
  });
}
function Su(t, e) {
  return Ge(this, void 0, void 0, function* () {
    return (yield fetch(t, {
      method: "PUT",
      body: e,
      headers: {
        "Content-Type": e.type
      }
    })).ok;
  });
}
function Ou(t) {
  return Ge(this, arguments, void 0, function* ({ apiURI: e, appId: n, path: r, refreshToken: i }) {
    const { data: s } = yield te(`${e}/storage/signed-download-url?app_id=${n}&filename=${encodeURIComponent(r)}`, {
      method: "GET",
      headers: {
        "content-type": "application/json",
        authorization: `Bearer ${i}`
      }
    });
    return s;
  });
}
let hn = !1, ri = !1, ii = !1;
typeof window < "u" && typeof window.localStorage < "u" && (hn = !!window.localStorage.getItem("devBackend"), ri = !!window.localStorage.getItem("__instantLogging"), ii = !!window.localStorage.getItem("__devtoolLocalDash"));
function ir(t, e) {
  if (!e)
    return t;
  const n = {};
  return e.forEach((r) => {
    n[r] = t[r];
  }), n;
}
function Eu(t, e, n) {
  var r, i;
  const s = {
    peers: {}
  };
  if (e && "user" in e ? e.user : !0) {
    const u = ir((r = t.user) !== null && r !== void 0 ? r : {}, e == null ? void 0 : e.keys);
    s.user = Object.assign(Object.assign({}, u), { peerId: n });
  }
  for (const u of Object.keys((i = t.peers) !== null && i !== void 0 ? i : {})) {
    const a = (e == null ? void 0 : e.peers) === void 0, d = Array.isArray(e == null ? void 0 : e.peers) && (e == null ? void 0 : e.peers.includes(u));
    if (a || d) {
      const c = ir(t.peers[u], e == null ? void 0 : e.keys);
      s.peers[u] = Object.assign(Object.assign({}, c), { peerId: u });
    }
  }
  return s;
}
function Au(t, e) {
  if (t.isLoading !== e.isLoading || t.error !== e.error || (t.user || e.user) && (!t.user || !e.user || !zn(t.user, e.user)) || !Mr(t.peers, e.peers))
    return !0;
  for (const r of Object.keys(t.peers))
    if (!zn(t.peers[r], e.peers[r]))
      return !0;
  return !1;
}
class sr {
  constructor() {
    this.promise = new Promise((e, n) => {
      this._resolve = e, this._reject = n;
    });
  }
  resolve(e) {
    this._resolve(e);
  }
  reject(e) {
    this._reject(e);
  }
}
function si(t, e = []) {
  t.forEach((n) => {
    const { data: r } = n, { "datalog-result": i } = r, { "join-rows": s } = i;
    for (const o of s)
      for (const u of o)
        e.push(u);
    si(n["child-nodes"], e);
  });
}
function or(t) {
  const e = [];
  return si(t, e), e;
}
function ur(t) {
  return Object.values(t.links).reduce((e, n) => {
    var r, i, s, o;
    return (r = e[s = n.forward.on]) !== null && r !== void 0 || (e[s] = {}), e[n.forward.on][n.forward.label] = {
      isForward: !0,
      isSingular: n.forward.has === "one",
      link: n
    }, (i = e[o = n.reverse.on]) !== null && i !== void 0 || (e[o] = {}), e[n.reverse.on][n.reverse.label] = {
      isForward: !1,
      isSingular: n.reverse.has === "one",
      link: n
    }, e;
  }, {});
}
const oi = "v0.22.88";
function ju(t, e) {
  return {
    info: t ? (...n) => console.info(...n, e()) : () => {
    },
    debug: t ? (...n) => console.debug(...n, e()) : () => {
    },
    error: t ? (...n) => console.error(...n, e()) : () => {
    }
  };
}
class ue {
  constructor(e, n, r, i = { indexed: !1, unique: !1 }) {
    this.valueType = e, this.required = n, this.isIndexed = r, this.config = i, this.metadata = {};
  }
  /**
   * @deprecated Only use this temporarily for attributes that you want
   * to treat as required in frontend code but cant yet mark as required
   * and enforced for backend
   */
  clientRequired() {
    return new ue(this.valueType, !1, this.isIndexed, this.config);
  }
  optional() {
    return new ue(this.valueType, !1, this.isIndexed, this.config);
  }
  unique() {
    return new ue(this.valueType, this.required, this.isIndexed, Object.assign(Object.assign({}, this.config), { unique: !0 }));
  }
  indexed() {
    return new ue(this.valueType, this.required, !0, Object.assign(Object.assign({}, this.config), { indexed: !0 }));
  }
}
class M extends Error {
  constructor(e, n) {
    const r = n ? `At path '${n}': ${e}` : e;
    super(r), this.name = "QueryValidationError";
  }
}
const ar = [
  "where",
  "order",
  "limit",
  "last",
  "first",
  "offset",
  "after",
  "before",
  "fields",
  "aggregate"
], ku = (t) => t.valueType || "unknown", ui = (t, e, n = !1) => {
  if (n || t == null)
    return !0;
  switch (e) {
    case "string":
      return typeof t == "string";
    case "number":
      return typeof t == "number" && !isNaN(t);
    case "boolean":
      return typeof t == "boolean";
    case "date":
      return t instanceof Date || typeof t == "string" || typeof t == "number";
    default:
      return !0;
  }
}, Cu = (t, e, n, r, i, s, o) => {
  const u = s.valueType === "json", a = (d, c, f) => {
    if (!ui(f, c, u))
      throw new M(`Invalid value for operator '${d}' on attribute '${r}' in entity '${i}'. Expected ${c}, but received: ${typeof f}`, o);
  };
  switch (t) {
    case "in":
    case "$in":
      if (!Array.isArray(e))
        throw new M(`Operator '${t}' for attribute '${r}' in entity '${i}' must be an array, but received: ${typeof e}`, o);
      for (const d of e)
        a(t, n, d);
      break;
    case "$not":
    case "$ne":
    case "$gt":
    case "$lt":
    case "$gte":
    case "$lte":
      a(t, n, e);
      break;
    case "$like":
    case "$ilike":
      if (a(t, "string", e), t === "$ilike" && !s.isIndexed)
        throw new M(`Operator '${t}' can only be used with indexed attributes, but '${r}' in entity '${i}' is not indexed`, o);
      break;
    case "$isNull":
      a(t, "boolean", e);
      break;
    default:
      throw new M(`Unknown operator '${t}' for attribute '${r}' in entity '${i}'`, o);
  }
}, Oe = (t, e, n, r, i) => {
  const s = ku(n), o = n.valueType === "json";
  if (typeof t == "object" && t !== null && !Array.isArray(t)) {
    if (o)
      return;
    const a = t;
    for (const [d, c] of Object.entries(a))
      Cu(d, c, s, e, r, n, `${i}.${d}`);
  } else if (!ui(t, s, o))
    throw new M(`Invalid value for attribute '${e}' in entity '${r}'. Expected ${s}, but received: ${typeof t}`, i);
}, Pu = (t, e, n, r, i) => {
  const s = t.split(".");
  if (s.length < 2)
    throw new M(`Invalid dot notation path '${t}'. Must contain at least one dot.`, i);
  let o = n;
  for (let c = 0; c < s.length - 1; c++) {
    const f = s[c], l = r.entities[o];
    if (!l)
      throw new M(`Entity '${o}' does not exist in schema while traversing dot notation path '${t}'.`, i);
    const p = l.links[f];
    if (!p) {
      const y = Object.keys(l.links);
      throw new M(`Link '${f}' does not exist on entity '${o}' in dot notation path '${t}'. Available links: ${y.length > 0 ? y.join(", ") : "none"}`, i);
    }
    o = p.entityName;
  }
  const u = s[s.length - 1], a = r.entities[o];
  if (!a)
    throw new M(`Target entity '${o}' does not exist in schema for dot notation path '${t}'.`, i);
  if (u === "id") {
    if (typeof e == "string" && !Ee(e))
      throw new M(`Invalid value for id field in entity '${o}'. Expected a UUID, but received: ${e}`, i);
    Oe(e, t, new ue("string", !1, !0), n, i);
    return;
  }
  const d = a.attrs[u];
  if (Object.keys(a.links).includes(u)) {
    if (typeof e == "string" && !Ee(e))
      throw new M(`Invalid value for link '${u}' in entity '${o}'. Expected a UUID, but received: ${e}`, i);
    Oe(e, t, new ue("string", !1, !0), n, i);
    return;
  }
  if (!d) {
    const c = Object.keys(a.attrs);
    throw new M(`Attribute '${u}' does not exist on entity '${o}' in dot notation path '${t}'. Available attributes: ${c.length > 0 ? c.join(", ") + ", id" : "id"}`, i);
  }
  Oe(e, t, d, n, i);
}, ai = (t, e, n, r) => {
  for (const [i, s] of Object.entries(t)) {
    if (i === "or" || i === "and") {
      if (Array.isArray(s))
        for (const d of s)
          typeof d == "object" && d !== null && ai(d, e, n, `${r}.${i}[${d}]`);
      continue;
    }
    if (i === "id") {
      Oe(s, "id", new ue("string", !1, !0), e, `${r}.id`);
      continue;
    }
    if (i.includes(".")) {
      Pu(i, s, e, n, `${r}.${i}`);
      continue;
    }
    const o = n.entities[e];
    if (!o)
      continue;
    const u = o.attrs[i], a = o.links[i];
    if (!u && !a) {
      const d = Object.keys(o.attrs), c = Object.keys(o.links);
      throw new M(`Attribute or link '${i}' does not exist on entity '${e}'. Available attributes: ${d.length > 0 ? d.join(", ") : "none"}. Available links: ${c.length > 0 ? c.join(", ") : "none"}`, `${r}.${i}`);
    }
    if (u)
      Oe(s, i, u, e, `${r}.${i}`);
    else if (a) {
      if (typeof s == "string" && !Ee(s))
        throw new M(`Invalid value for link '${i}' in entity '${e}'. Expected a UUID, but received: ${s}`, `${r}.${i}`);
      const d = new ue("string", !1, !0);
      Oe(s, i, d, e, `${r}.${i}`);
    }
  }
}, Iu = (t, e, n, r, i = 0) => {
  for (const o of Object.keys(t))
    if (!ar.includes(o))
      throw new M(`Invalid query parameter '${o}' in $ object. Valid parameters are: ${ar.join(", ")}. Found: ${o}`, r);
  const s = [
    // 'limit', // only supported client side
    "offset",
    "before",
    "after",
    "first",
    "last"
  ];
  for (const o of s)
    if (t[o] !== void 0 && i > 0)
      throw new M(`'${o}' can only be used on top-level namespaces. It cannot be used in nested queries.`, r);
  if (t.where && n) {
    if (typeof t.where != "object" || t.where === null)
      throw new M(`'where' clause must be an object in entity '${e}', but received: ${typeof t.where}`, r ? `${r}.where` : void 0);
    ai(t.where, e, n, r ? `${r}.where` : "where");
  }
}, ci = (t, e, n, r, i = 0) => {
  var s;
  if (!t || typeof t != "object")
    throw new M(`Query part for entity '${e}' must be an object, but received: ${typeof t}`, r);
  for (const o of Object.keys(t))
    if (o !== "$") {
      if (n && !(o in n.entities[e].links)) {
        const a = Object.keys(n.entities[e].links);
        throw new M(`Link '${o}' does not exist on entity '${e}'. Available links: ${a.length > 0 ? a.join(", ") : "none"}`, `${r}.${o}`);
      }
      const u = t[o];
      if (typeof u == "object" && u !== null) {
        const a = (s = n == null ? void 0 : n.entities[e].links[o]) === null || s === void 0 ? void 0 : s.entityName;
        a && ci(u, a, n, `${r}.${o}`, i + 1);
      }
    } else {
      const u = t[o];
      if (typeof u != "object" || u === null)
        throw new M(`Query parameter '$' must be an object in entity '${e}', but received: ${typeof u}`, `${r}.$`);
      Iu(u, e, n, `${r}.$`, i);
    }
}, cr = (t, e) => {
  if (typeof t != "object" || t === null)
    throw new M(`Query must be an object, but received: ${typeof t}${t === null ? " (null)" : ""}`);
  if (Array.isArray(t))
    throw new M(`Query must be an object, but received: ${typeof t}`);
  const n = t;
  for (const r of Object.keys(n)) {
    if (Array.isArray(t[r]))
      throw new M(`Query keys must be strings, but found key of type: ${typeof r}`, r);
    if (typeof r != "string")
      throw new M(`Query keys must be strings, but found key of type: ${typeof r}`, r);
    if (r !== "$$ruleParams") {
      if (e && !e.entities[r]) {
        const i = Object.keys(e.entities);
        throw new M(`Entity '${r}' does not exist in schema. Available entities: ${i.length > 0 ? i.join(", ") : "none"}`, r);
      }
      ci(n[r], r, e, r, 0);
    }
  }
}, dr = (t) => typeof t != "string" ? !1 : ht(t) ? !0 : Ee(t);
class Z extends Error {
  constructor(e) {
    super(e), this.name = "TransactionValidationError";
  }
}
const di = (t) => t.length > 0 ? t.join(", ") : "none", Mu = (t, e) => new Z(`Entity '${t}' does not exist in schema. Available entities: ${di(e)}`), fr = {
  string: (t) => typeof t == "string",
  number: (t) => typeof t == "number" && !isNaN(t),
  boolean: (t) => typeof t == "boolean",
  date: (t) => t instanceof Date || typeof t == "string" || typeof t == "number",
  json: () => !0
}, Ru = (t, e) => {
  var n, r;
  return t == null ? !0 : (r = (n = fr[e.valueType]) === null || n === void 0 ? void 0 : n.call(fr, t)) !== null && r !== void 0 ? r : !1;
}, fi = (t, e) => {
  const n = e.entities[t];
  if (!n)
    throw Mu(t, Object.keys(e.entities));
  return n;
}, Ct = (t, e, n) => {
  const r = fi(t, n);
  if (typeof e != "object" || e === null)
    throw new Z(`Arguments for data operation on entity '${t}' must be an object, but received: ${typeof e}`);
  for (const [i, s] of Object.entries(e)) {
    if (i === "id")
      continue;
    const o = r.attrs[i];
    if (o && !Ru(s, o))
      throw new Z(`Invalid value for attribute '${i}' in entity '${t}'. Expected ${o.valueType}, but received: ${typeof s}`);
  }
}, lr = (t, e, n) => {
  const r = fi(t, n);
  if (typeof e != "object" || e === null)
    throw new Z(`Arguments for link operation on entity '${t}' must be an object, but received: ${typeof e}`);
  for (const [i, s] of Object.entries(e)) {
    if (!r.links[i]) {
      const u = Object.keys(r.links);
      throw new Z(`Link '${i}' does not exist on entity '${t}'. Available links: ${di(u)}`);
    }
    if (s != null) {
      if (Array.isArray(s)) {
        for (const u of s)
          if (!dr(u))
            throw new Z(`Invalid entity ID in link '${i}' for entity '${t}'. Expected a UUID or a lookup, but received: ${u}`);
      } else if (!dr(s))
        throw new Z(`Invalid UUID in link '${i}' for entity '${t}'. Expected a UUID, but received: ${s}`);
    }
  }
}, $u = {
  create: Ct,
  update: Ct,
  merge: Ct,
  link: lr,
  unlink: lr,
  delete: () => {
  }
}, xu = (t, e) => {
  if (!e)
    return;
  const [n, r, i, s] = t;
  if (!Array.isArray(i) && !Ee(i))
    throw new Z(`Invalid id for entity '${r}'. Expected a UUID, but received: ${i}`);
  if (typeof r != "string")
    throw new Z(`Entity name must be a string, but received: ${typeof r}`);
  const o = $u[n];
  o && s !== void 0 && o(r, s, e);
}, Du = (t, e) => {
  const n = Array.isArray(t) ? t : [t];
  for (const r of n) {
    if (!r || typeof r != "object")
      throw new Z(`Transaction chunk must be an object, but received: ${typeof r}`);
    if (!Array.isArray(r.__ops))
      throw new Z(`Transaction chunk must have __ops array, but received: ${typeof r.__ops}`);
    for (const i of r.__ops) {
      if (!Array.isArray(i))
        throw new Z(`Transaction operation must be an array, but received: ${typeof i}`);
      xu(i, e);
    }
  }
};
var hr = function(t, e, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function u(c) {
      try {
        d(r.next(c));
      } catch (f) {
        o(f);
      }
    }
    function a(c) {
      try {
        d(r.throw(c));
      } catch (f) {
        o(f);
      }
    }
    function d(c) {
      c.done ? s(c.value) : i(c.value).then(u, a);
    }
    d((r = r.apply(t, e || [])).next());
  });
};
let li = 0;
class pr {
  constructor(e) {
    this.type = "ws", this.id = `${this.type}_${li++}`, this.conn = new WebSocket(e), this.conn.onopen = (n) => {
      this.onopen && this.onopen({ target: this });
    }, this.conn.onmessage = (n) => {
      this.onmessage && this.onmessage({
        target: this,
        message: JSON.parse(n.data.toString())
      });
    }, this.conn.onclose = (n) => {
      this.onclose && this.onclose({ target: this });
    }, this.conn.onerror = (n) => {
      this.onerror && this.onerror({ target: this });
    };
  }
  close() {
    this.conn.close();
  }
  isOpen() {
    var e;
    return this.conn.readyState === ((e = WebSocket.OPEN) !== null && e !== void 0 ? e : 1);
  }
  isConnecting() {
    var e;
    return this.conn.readyState === ((e = WebSocket.CONNECTING) !== null && e !== void 0 ? e : 0);
  }
  send(e) {
    return this.conn.send(JSON.stringify(e));
  }
}
class Uu {
  constructor(e, n) {
    this.type = "sse", this.initParams = null, this.sendQueue = [], this.closeFired = !1, this.sseInitTimeout = void 0, this.id = `${this.type}_${li++}`, this.url = n, this.ES = e, this.conn = new e(n), this.sseInitTimeout = setTimeout(() => {
      this.initParams || this.handleError();
    }, 1e4), this.conn.onmessage = (r) => {
      const i = JSON.parse(r.data);
      if (Array.isArray(i))
        for (const s of i)
          this.handleMessage(s);
      else
        this.handleMessage(i);
    }, this.conn.onerror = (r) => {
      this.handleError();
    };
  }
  handleMessage(e) {
    if (e.op === "sse-init") {
      this.initParams = {
        machineId: e["machine-id"],
        sessionId: e["session-id"],
        sseToken: e["sse-token"]
      }, this.onopen && this.onopen({ target: this }), clearTimeout(this.sseInitTimeout);
      return;
    }
    this.onmessage && this.onmessage({
      target: this,
      message: e
    });
  }
  // Runs the onerror and closes the connection
  handleError() {
    try {
      this.onerror && this.onerror({ target: this });
    } finally {
      this.handleClose();
    }
  }
  handleClose() {
    this.conn.close(), this.onclose && !this.closeFired && (this.closeFired = !0, this.onclose({ target: this }));
  }
  postMessages(e) {
    return hr(this, void 0, void 0, function* () {
      var n, r, i;
      try {
        (yield fetch(this.url, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            machine_id: (n = this.initParams) === null || n === void 0 ? void 0 : n.machineId,
            session_id: (r = this.initParams) === null || r === void 0 ? void 0 : r.sessionId,
            sse_token: (i = this.initParams) === null || i === void 0 ? void 0 : i.sseToken,
            messages: e
          })
        })).ok || this.handleError();
      } catch {
        this.handleError();
      }
    });
  }
  flushQueue() {
    return hr(this, void 0, void 0, function* () {
      if (this.sendPromise || !this.sendQueue.length)
        return;
      const e = this.sendQueue;
      this.sendQueue = [];
      const n = this.postMessages(e);
      this.sendPromise = n, n.then(() => {
        this.sendPromise = null, this.flushQueue();
      });
    });
  }
  send(e) {
    if (!this.isOpen() || !this.initParams)
      throw this.isConnecting() ? new Error("Failed to execute 'send' on 'EventSource': Still in CONNECTING state.") : this.conn.readyState === this.ES.CLOSED ? new Error("EventSource is already in CLOSING or CLOSED state.") : new Error("EventSource is in invalid state.");
    this.sendQueue.push(e), this.flushQueue();
  }
  isOpen() {
    return this.conn.readyState === this.ES.OPEN && this.initParams !== null;
  }
  isConnecting() {
    return this.conn.readyState === this.ES.CONNECTING || this.conn.readyState === this.ES.OPEN && this.initParams === null;
  }
  close() {
    this.handleClose();
  }
}
var yr = function(t, e, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function u(c) {
      try {
        d(r.next(c));
      } catch (f) {
        o(f);
      }
    }
    function a(c) {
      try {
        d(r.throw(c));
      } catch (f) {
        o(f);
      }
    }
    function d(c) {
      c.done ? s(c.value) : i(c.value).then(u, a);
    }
    d((r = r.apply(t, e || [])).next());
  });
};
function Lu(t, e) {
  const n = t.values;
  if (n)
    for (const r of n.entities || [])
      r.store.useDateObjects = e, r.store.attrs = n.attrs, r.store = Lr(r.store);
  return t;
}
function Fu(t, e) {
  var n, r;
  if (!((n = e.values) === null || n === void 0) && n.entities) {
    const i = [];
    for (const s of (r = e.values) === null || r === void 0 ? void 0 : r.entities) {
      const o = Ur(s.store);
      delete o.attrs, i.push(Object.assign(Object.assign({}, s), { store: o }));
    }
    return Object.assign(Object.assign({}, e), { values: Object.assign(Object.assign({}, e.values), { entities: i }) });
  } else
    return e;
}
function Nu(t, e, n) {
  var r, i;
  const s = (r = e == null ? void 0 : e.state) === null || r === void 0 ? void 0 : r.txId, o = (i = n == null ? void 0 : n.state) === null || i === void 0 ? void 0 : i.txId;
  return s && (!o || s > o) ? e : o && (!s || o > s) ? n : e || n;
}
function Pt(t, e) {
  return Jr({ store: e, pageInfo: null, aggregate: null }, t.query).data[t.table][0];
}
function br(t, e, n) {
  var r;
  const i = (r = fe(e, t.table, "id")) === null || r === void 0 ? void 0 : r.id;
  if (!i)
    return -1;
  const s = Ce(e.eav, [n, i, n]);
  return s ? s[3] : -1;
}
function _r(t, e) {
  for (const { action: n, triple: r } of e)
    switch (n) {
      case "added":
        Kr(t, r);
        break;
      case "removed":
        Fr(t, r);
        break;
    }
}
function Ku(t, e) {
  var n, r, i, s;
  const o = {};
  for (const { action: u, triple: a } of e) {
    const [d, c, f] = a, l = (r = (n = t.attrs[c]) === null || n === void 0 ? void 0 : n["forward-identity"]) === null || r === void 0 ? void 0 : r[2];
    if (!l)
      continue;
    const p = (i = o[d]) !== null && i !== void 0 ? i : {};
    o[d] = p;
    const y = (s = p[l]) !== null && s !== void 0 ? s : {};
    switch (p[l] = y, u) {
      case "added":
        y.newValue = f;
        break;
      case "removed":
        y.oldValue === void 0 && (y.oldValue = f);
        break;
    }
  }
  for (const u of Object.keys(o)) {
    const { oldValue: a, newValue: d } = o[u];
    a === d && delete o[u];
  }
  return o;
}
function rt(t, e) {
  return { [t.table]: e.map((n) => n.entity) };
}
function qu(t, e) {
  var n;
  if (t.orderFieldType)
    return t.orderFieldType;
  const r = t.orderField === "serverCreatedAt" ? "number" : (n = fe(e([]), t.table, t.orderField)) === null || n === void 0 ? void 0 : n["checked-data-type"];
  return t.orderFieldType = r, r;
}
function zu(t, e, n) {
  const r = e;
  if (t.orderField === "serverCreatedAt") {
    n.sort(t.orderDirection === "asc" ? function(o, u) {
      return Fe(o.entity.id, o.serverCreatedAt, u.entity.id, u.serverCreatedAt, r);
    } : function(o, u) {
      return Fe(u.entity.id, u.serverCreatedAt, o.entity.id, o.serverCreatedAt, r);
    });
    return;
  }
  const i = t.orderField;
  n.sort(t.orderDirection === "asc" ? function(o, u) {
    return Fe(o.entity.id, o.entity[i], u.entity.id, u.entity[i], r);
  } : function(o, u) {
    return Fe(u.entity.id, u.entity[i], o.entity.id, o.entity[i], r);
  });
}
var pe;
(function(t) {
  t.InitialSyncBatch = "InitialSyncBatch", t.InitialSyncComplete = "InitialSyncComplete", t.LoadFromStorage = "LoadFromStorage", t.SyncTransaction = "SyncTransaction", t.Error = "Error";
})(pe || (pe = {}));
class Vu {
  constructor(e, n, r, i, s) {
    this.callbacks = {}, this.idToHash = {}, this.trySend = e, this.config = r, this.log = i, this.createStore = s, this.subs = new Yt({
      persister: n,
      merge: Nu,
      serialize: Fu,
      parse: (o, u) => Lu(u, this.config.useDateObjects),
      objectSize: (o) => {
        var u;
        return ((u = o.values) === null || u === void 0 ? void 0 : u.entities.length) || 0;
      },
      logger: i,
      gc: {
        maxAgeMs: 1e3 * 60 * 60 * 24 * 7 * 52,
        // 1 year
        maxEntries: 1e3,
        // Size of each sub is the number of entity
        maxSize: 1e6
        // 1 million entities
      }
    });
  }
  beforeUnload() {
    this.subs.flush();
  }
  subscribe(e, n) {
    const r = N(e);
    return this.callbacks[r] = this.callbacks[r] || [], this.callbacks[r].push(n), this.initSubscription(e, r, n), (i) => {
      this.unsubscribe(r, n, i == null ? void 0 : i.keepSubscription);
    };
  }
  unsubscribe(e, n, r) {
    const i = (this.callbacks[e] || []).filter((s) => s !== n);
    if (this.callbacks[e] = i, !i.length) {
      delete this.callbacks[e];
      const s = this.subs.currentValue[e];
      s != null && s.state && this.clearSubscriptionData(s.state.subscriptionId, !!r), r || this.subs.updateInPlace((o) => {
        delete o[e];
      });
    }
  }
  sendStart(e) {
    this.trySend(L(), {
      op: "start-sync",
      q: e
    });
  }
  sendResync(e, n, r) {
    this.idToHash[n.subscriptionId] = e.hash, this.trySend(n.subscriptionId, {
      op: "resync-table",
      "subscription-id": n.subscriptionId,
      "tx-id": r,
      token: n.token
    });
  }
  sendRemove(e, n) {
    this.trySend(L(), {
      op: "remove-sync",
      "subscription-id": e.subscriptionId,
      "keep-subscription": n
    });
  }
  initSubscription(e, n, r) {
    return yr(this, void 0, void 0, function* () {
      var i, s, o, u;
      yield this.subs.waitForKeyToLoad(n);
      const a = this.subs.currentValue[n];
      if (a && a.state && a.state.txId) {
        this.sendResync(a, a.state, a.state.txId), !((i = a.values) === null || i === void 0) && i.entities && r && r({
          type: pe.LoadFromStorage,
          data: rt(a, (s = a.values) === null || s === void 0 ? void 0 : s.entities)
        });
        return;
      }
      const d = Object.keys(e)[0], c = ((u = (o = e[d]) === null || o === void 0 ? void 0 : o.$) === null || u === void 0 ? void 0 : u.order) || { serverCreatedAt: "asc" }, [f, l] = Object.entries(c)[0];
      this.subs.updateInPlace((p) => {
        p[n] = {
          query: e,
          hash: n,
          table: d,
          orderDirection: l,
          orderField: f,
          createdAt: Date.now(),
          updatedAt: Date.now()
        };
      }), this.sendStart(e);
    });
  }
  flushPending() {
    return yr(this, void 0, void 0, function* () {
      for (const e of Object.keys(this.callbacks)) {
        yield this.subs.waitForKeyToLoad(e);
        const n = this.subs.currentValue[e];
        n ? yield this.initSubscription(n.query, n.hash) : this.log.error("Missing sub for hash in flushPending", e);
      }
    });
  }
  onStartSyncOk(e) {
    const n = e["subscription-id"], r = e.q, i = N(r);
    this.idToHash[n] = i, this.subs.updateInPlace((s) => {
      const o = s[i];
      if (!o)
        return this.log.error("Missing sub for hash", i, "subscription-id", n, "query", r), s;
      o.state = {
        subscriptionId: n,
        token: e.token
      };
    });
  }
  notifyCbs(e, n) {
    for (const r of this.callbacks[e] || [])
      r(n);
  }
  onSyncLoadBatch(e) {
    var n;
    const r = e["subscription-id"], i = e["join-rows"], s = this.idToHash[r];
    if (!s) {
      this.log.error("Missing hash for subscription", e);
      return;
    }
    const o = [], u = this.subs.currentValue[s];
    if (!u) {
      this.log.error("Missing sub for hash", s, e);
      return;
    }
    const a = (n = u.values) !== null && n !== void 0 ? n : {
      entities: [],
      attrs: this.createStore([]).attrs
    };
    u.values = a;
    const d = a.entities;
    for (const c of i) {
      const f = this.createStore(c);
      a.attrs = f.attrs;
      const l = Pt(u, f);
      d.push({
        store: f,
        entity: l,
        serverCreatedAt: br(u, f, l.id)
      }), o.push(l);
    }
    this.subs.updateInPlace((c) => {
      c[s] = u, c[s].updatedAt = Date.now();
    }), u.values && this.notifyCbs(s, {
      type: pe.InitialSyncBatch,
      data: rt(u, u.values.entities),
      batch: o
    });
  }
  onSyncInitFinish(e) {
    var n;
    const r = e["subscription-id"], i = this.idToHash[r];
    if (!i) {
      this.log.error("Missing hash for subscription", e);
      return;
    }
    this.subs.updateInPlace((o) => {
      const u = o[i];
      if (!u) {
        this.log.error("Missing sub for hash", i, e);
        return;
      }
      const a = u.state;
      if (!a)
        return this.log.error("Sub never set init, missing result", u, e), o;
      a.txId = e["tx-id"], u.updatedAt = Date.now();
    });
    const s = this.subs.currentValue[i];
    s && this.notifyCbs(i, {
      type: pe.InitialSyncComplete,
      data: rt(s, ((n = s.values) === null || n === void 0 ? void 0 : n.entities) || [])
    });
  }
  onSyncUpdateTriples(e) {
    var n, r, i;
    const s = e["subscription-id"], o = this.idToHash[s];
    if (!o) {
      this.log.error("Missing hash for subscription", e);
      return;
    }
    const u = this.subs.currentValue[o];
    if (!u) {
      this.log.error("Missing sub for hash", o, e);
      return;
    }
    const a = u.state;
    if (!a) {
      this.log.error("Missing state for sub", u, e);
      return;
    }
    for (const d of e.txes) {
      if (a.txId && a.txId >= d["tx-id"])
        continue;
      a.txId = d["tx-id"];
      const c = [], f = {};
      for (const T of d.changes) {
        const v = (n = f[T.triple[0]]) !== null && n !== void 0 ? n : [];
        f[T.triple[0]] = v, v.push(T);
      }
      const l = (r = u.values) !== null && r !== void 0 ? r : {
        entities: [],
        attrs: this.createStore([]).attrs
      }, p = l.entities;
      u.values = l;
      const y = [];
      e: for (const [T, v] of Object.entries(f))
        for (let k = 0; k < p.length; k++) {
          const S = p[k];
          if (vs(S.store, T)) {
            _r(S.store, v);
            const I = Pt(u, S.store), R = Ku(S.store, v)[T];
            I ? (y.push({
              oldEntity: S.entity,
              newEntity: I,
              changedFields: R || {}
            }), S.entity = I) : c.push(k), delete f[T];
            continue e;
          }
        }
      const b = [];
      for (const [T, v] of Object.entries(f)) {
        const k = this.createStore([]);
        l.attrs = k.attrs, _r(k, v);
        const S = Pt(u, k);
        if (!S) {
          this.log.error("No entity found after applying change", {
            sub: u,
            changes: v,
            store: k
          });
          continue;
        }
        p.push({
          store: k,
          entity: S,
          serverCreatedAt: br(u, k, S.id)
        }), b.push(S);
      }
      const g = [];
      for (const T of c.sort().reverse())
        g.push(p[T].entity), p.splice(T, 1);
      const m = qu(u, this.createStore);
      zu(u, m, p), this.notifyCbs(o, {
        type: pe.SyncTransaction,
        data: rt(u, (i = u.values) === null || i === void 0 ? void 0 : i.entities),
        added: b,
        removed: g,
        updated: y
      });
    }
    this.subs.updateInPlace((d) => {
      d[o] = u, d[o].updatedAt = Date.now();
    });
  }
  clearSubscriptionData(e, n) {
    const r = this.idToHash[e];
    if (r) {
      delete this.idToHash[e];
      const i = this.subs.currentValue[r];
      if (i.state && this.sendRemove(i.state, n), n ? this.subs.unloadKey(r) : this.subs.updateInPlace((s) => {
        delete s[r];
      }), i)
        return i;
    }
  }
  onStartSyncError(e) {
    const n = N(e["original-event"].q), r = {
      message: e.message || "Uh-oh, something went wrong. Ping Joe & Stopa.",
      status: e.status,
      type: e.type,
      hint: e.hint
    }, i = Object.keys(e["original-event"].q)[0];
    this.notifyCbs(n, {
      type: pe.Error,
      data: { [i]: [] },
      error: r
    });
  }
  onResyncError(e) {
    const n = e["original-event"]["subscription-id"], r = this.clearSubscriptionData(n, !1);
    r && this.initSubscription(r.query, r.hash);
  }
}
var U = function(t, e, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function u(c) {
      try {
        d(r.next(c));
      } catch (f) {
        o(f);
      }
    }
    function a(c) {
      try {
        d(r.throw(c));
      } catch (f) {
        o(f);
      }
    }
    function d(c) {
      c.done ? s(c.value) : i(c.value).then(u, a);
    }
    d((r = r.apply(t, e || [])).next());
  });
}, Wu = function(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
  return n;
};
const se = {
  CONNECTING: "connecting",
  OPENED: "opened",
  AUTHENTICATED: "authenticated",
  CLOSED: "closed",
  ERRORED: "errored"
}, Bu = 3e4, Gu = 3e4, Qu = 200, Hu = {
  apiURI: "https://api.instantdb.com",
  websocketURI: "wss://api.instantdb.com/runtime/session"
}, It = "_instant_oauth_redirect", De = "currentUser";
function Yu({ transportType: t, appId: e, apiURI: n, wsURI: r, EventSourceImpl: i }) {
  if (!i)
    return new pr(`${r}?app_id=${e}`);
  switch (t) {
    case "ws":
      return new pr(`${r}?app_id=${e}`);
    case "sse":
      return new Uu(i, `${n}/runtime/sse?app_id=${e}`);
    default:
      throw new Error("Unknown transport type " + t);
  }
}
function Ju() {
  return typeof window < "u" || typeof chrome < "u";
}
const gr = {
  "set-presence": !0,
  "set-presence-ok": !0,
  "refresh-presence": !0,
  "patch-presence": !0
};
function Zu(t, e) {
  var n;
  const r = typeof t == "string" ? JSON.parse(t) : t;
  if (!((n = r == null ? void 0 : r.result) === null || n === void 0) && n.store) {
    const i = r.result.store;
    r.result.store = Lr(Object.assign(Object.assign({}, i), { useDateObjects: e }));
  }
  return r;
}
function Xu(t, e) {
  var n;
  const r = Object.assign({}, e);
  return !((n = e.result) === null || n === void 0) && n.store && (r.result = Object.assign(Object.assign({}, e.result), { store: Ur(e.result.store) })), r;
}
function ea(t, e) {
  switch (t) {
    case "pendingMutations":
      return new Map(typeof e == "string" ? JSON.parse(e) : e);
    default:
      return e;
  }
}
function ta(t, e) {
  switch (t) {
    case "pendingMutations":
      return [...e.entries()];
    default:
      return e;
  }
}
function na(t, e, n) {
  const r = e == null ? void 0 : e.result, i = n == null ? void 0 : n.result;
  return r && !i && n && (n.result = r), n || e;
}
function Tr(t) {
  return [...t].sort((e, n) => {
    const [r, i] = e, [s, o] = n, u = i.order || 0, a = o.order || 0;
    return u == a ? r < s ? -1 : r > s ? 1 : 0 : u - a;
  });
}
class ra {
  constructor(e, n = ti, r = ni, i, s) {
    var o, u, a;
    if (this._isOnline = !0, this._isShutdown = !1, this.status = se.CONNECTING, this.queryCbs = {}, this.queryOnceDfds = {}, this.authCbs = [], this.attrsCbs = [], this.mutationErrorCbs = [], this.connectionStatusCbs = [], this.mutationDeferredStore = /* @__PURE__ */ new Map(), this._reconnectTimeoutId = null, this._reconnectTimeoutMs = 0, this._transportType = "ws", this._wsOk = null, this._localIdPromises = {}, this._errorMessage = null, this._oauthCallbackResponse = null, this._linkIndex = null, this._rooms = {}, this._roomsPendingLeave = {}, this._presence = {}, this._broadcastQueue = [], this._broadcastSubs = {}, this._currentUserCached = { isLoading: !0, error: void 0, user: void 0 }, this._beforeUnloadCbs = [], this._dataForQueryCache = {}, this._inFlightMutationEventIds = /* @__PURE__ */ new Set(), this._onMergeKv = (d, c, f) => {
      var l, p;
      switch (d) {
        case "pendingMutations": {
          const y = (l = c == null ? void 0 : c.entries()) !== null && l !== void 0 ? l : [], b = (p = f == null ? void 0 : f.entries()) !== null && p !== void 0 ? p : [], g = new Map([...y, ...b]);
          return (c ? this._rewriteMutationsSorted(this.attrs, c) : []).forEach(([T, v]) => {
            var k;
            !(!((k = f == null ? void 0 : f.pendingMutations) === null || k === void 0) && k.has(T)) && !v["tx-id"] && this._sendMutation(T, v);
          }), g;
        }
        default:
          return f || c;
      }
    }, this.getPreviousResult = (d) => {
      var c;
      const f = N(d);
      return (c = this.dataForQuery(f)) === null || c === void 0 ? void 0 : c.data;
    }, this.notifyOne = (d) => {
      var c, f;
      const l = (c = this.queryCbs[d]) !== null && c !== void 0 ? c : [], p = (f = this._dataForQueryCache[d]) === null || f === void 0 ? void 0 : f.data, y = this.dataForQuery(d);
      y != null && y.data && (this._dataForQueryCache[d] = y, !ut(y.data, p) && l.forEach((b) => b.cb(y.data)));
    }, this.notifyOneQueryOnce = (d) => {
      var c, f;
      const l = (c = this.queryOnceDfds[d]) !== null && c !== void 0 ? c : [], p = (f = this.dataForQuery(d)) === null || f === void 0 ? void 0 : f.data;
      l.forEach((y) => {
        this._completeQueryOnce(y.q, d, y.dfd), y.dfd.resolve(p);
      });
    }, this.notifyQueryError = (d, c) => {
      (this.queryCbs[d] || []).forEach((l) => l.cb({ error: c }));
    }, this.pushTx = (d) => {
      this.config.disableValidation || Du(d, this.config.schema);
      try {
        const c = iu({
          attrs: this.optimisticAttrs(),
          schema: this.config.schema,
          stores: Object.values(this.querySubs.currentValue).map((f) => {
            var l;
            return (l = f == null ? void 0 : f.result) === null || l === void 0 ? void 0 : l.store;
          }),
          useDateObjects: this.config.useDateObjects
        }, d);
        return this.pushOps(c);
      } catch (c) {
        return this.pushOps([], c);
      }
    }, this.pushOps = (d, c) => {
      const f = L(), l = [...this._pendingMutations().values()], p = Math.max(0, ...l.map((g) => g.order || 0)) + 1, y = {
        op: "transact",
        "tx-steps": d,
        created: Date.now(),
        error: c,
        order: p
      };
      this._updatePendingMutations((g) => {
        g.set(f, y);
      });
      const b = new sr();
      return this.mutationDeferredStore.set(f, b), this._sendMutation(f, y), this.notifyAll(), b.promise;
    }, this._transportOnOpen = (d) => {
      const c = d.target;
      if (this._transport !== c) {
        this._log.info("[socket][open]", c.id, "skip; this is no longer the current transport");
        return;
      }
      this._log.info("[socket][open]", this._transport.id), this._setStatus(se.OPENED), this.getCurrentUser().then((f) => {
        var l;
        this._trySend(L(), {
          op: "init",
          "app-id": this.config.appId,
          "refresh-token": (l = f.user) === null || l === void 0 ? void 0 : l.refresh_token,
          versions: this.versions,
          // If an admin token is provided for an app, we will
          // skip all permission checks. This is an advanced feature,
          // to let users write internal tools
          // This option is not exposed in `Config`, as it's
          // not ready for prime time
          "__admin-token": this.config.__adminToken
        });
      }).catch((f) => {
        this._log.error("[socket][error]", c.id, f);
      });
    }, this._transportOnMessage = (d) => {
      const c = d.target, f = d.message;
      if (this._transport !== c) {
        this._log.info("[socket][message]", c.id, f, "skip; this is no longer the current transport");
        return;
      }
      if (!this._wsOk && c.type === "ws" && (this._wsOk = !0), this._transportType = "ws", Array.isArray(d.message))
        for (const l of d.message)
          this._handleReceive(c.id, l);
      else
        this._handleReceive(c.id, d.message);
    }, this._transportOnError = (d) => {
      const c = d.target;
      if (this._transport !== c) {
        this._log.info("[socket][error]", c.id, "skip; this is no longer the current transport");
        return;
      }
      this._log.error("[socket][error]", c.id, d);
    }, this._scheduleReconnect = () => {
      !this._wsOk && this._transportType !== "sse" && (this._transportType = "sse", this._reconnectTimeoutMs = 0), setTimeout(() => {
        if (this._reconnectTimeoutMs = Math.min(this._reconnectTimeoutMs + 1e3, 1e4), !this._isOnline) {
          this._log.info("[socket][close]", this._transport.id, "we are offline, no need to start socket");
          return;
        }
        this._startSocket();
      }, this._reconnectTimeoutMs);
    }, this._transportOnClose = (d) => {
      const c = d.target;
      if (this._transport !== c) {
        this._log.info("[socket][close]", c.id, "skip; this is no longer the current transport");
        return;
      }
      this._setStatus(se.CLOSED);
      for (const f of Object.values(this._rooms))
        f.isConnected = !1;
      if (this._isShutdown) {
        this._log.info("[socket][close]", c.id, "Reactor has been shut down and will not reconnect");
        return;
      }
      this._log.info("[socket][close]", c.id, "schedule reconnect, ms =", this._reconnectTimeoutMs), this._scheduleReconnect();
    }, this._EventSource = s, this.config = Object.assign(Object.assign({}, Hu), e), this.queryCacheLimit = (o = this.config.queryCacheLimit) !== null && o !== void 0 ? o : 10, this._pendingTxCleanupTimeout = (u = this.config.pendingTxCleanupTimeout) !== null && u !== void 0 ? u : Gu, this._pendingMutationCleanupThreshold = (a = this.config.pendingMutationCleanupThreshold) !== null && a !== void 0 ? a : Qu, this._log = ju(e.verbose || hn || ri, () => this._reactorStats()), this.versions = Object.assign(Object.assign({}, i || {}), { "@instantdb/core": oi }), this.config.schema && (this._linkIndex = ur(this.config.schema)), !!Ju()) {
      if (!e.appId)
        throw new Error("Instant must be initialized with an appId.");
      if (!Ee(e.appId))
        throw new Error(`Instant must be initialized with a valid appId. \`${e.appId}\` is not a valid uuid.`);
      typeof BroadcastChannel == "function" && (this._broadcastChannel = new BroadcastChannel("@instantdb"), this._broadcastChannel.addEventListener("message", (d) => U(this, void 0, void 0, function* () {
        var c;
        try {
          if (((c = d.data) === null || c === void 0 ? void 0 : c.type) === "auth") {
            const f = yield this.getCurrentUser();
            this.updateUser(f.user);
          }
        } catch (f) {
          this._log.error("[error] handle broadcast channel", f);
        }
      }))), this._initStorage(n), this._syncTable = new Vu(this._trySendAuthed.bind(this), new n(this.config.appId, "syncSubs"), {
        useDateObjects: this.config.useDateObjects
      }, this._log, (d) => at(this.attrs, d, this.config.enableCardinalityInference, this._linkIndex, this.config.useDateObjects)), this._oauthCallbackResponse = this._oauthLoginInit(), this.getCurrentUser(), r.getIsOnline().then((d) => {
        this._isOnline = d, this._startSocket(), r.listen((c) => {
          c !== this._isOnline && (this._log.info("[network] online =", c), this._isOnline = c, this._isOnline ? this._startSocket() : (this._log.info("Changing status from", this.status, "to", se.CLOSED), this._setStatus(se.CLOSED)));
        });
      }), typeof addEventListener < "u" && (this._beforeUnload = this._beforeUnload.bind(this), addEventListener("beforeunload", this._beforeUnload));
    }
  }
  updateSchema(e) {
    this.config = Object.assign(Object.assign({}, this.config), { schema: e, cardinalityInference: !!e }), this._linkIndex = e ? ur(this.config.schema) : null;
  }
  _reactorStats() {
    return {
      inFlightMutationCount: this._inFlightMutationEventIds.size,
      storedMutationCount: this._pendingMutations().size,
      transportType: this._transportType
    };
  }
  _onQuerySubLoaded(e) {
    this.kv.waitForKeyToLoad("pendingMutations").then(() => this.notifyOne(e));
  }
  _initStorage(e) {
    this.querySubs = new Yt({
      persister: new e(this.config.appId, "querySubs"),
      merge: na,
      serialize: Xu,
      parse: (n, r) => Zu(r, this.config.useDateObjects),
      // objectSize
      objectSize: (n) => {
        var r, i, s, o;
        return (o = (s = (i = (r = n.result) === null || r === void 0 ? void 0 : r.store) === null || i === void 0 ? void 0 : i.triples) === null || s === void 0 ? void 0 : s.length) !== null && o !== void 0 ? o : 0;
      },
      logger: this._log,
      preloadEntryCount: 10,
      gc: {
        maxAgeMs: 1e3 * 60 * 60 * 24 * 7 * 52,
        // 1 year
        maxEntries: 1e3,
        // Size of each query is the number of triples
        maxSize: 1e6
        // 1 million triples
      }
    }), this.querySubs.onKeyLoaded = (n) => this._onQuerySubLoaded(n), this.kv = new Yt({
      persister: new e(this.config.appId, "kv"),
      merge: this._onMergeKv,
      serialize: ta,
      parse: ea,
      objectSize: () => 0,
      logger: this._log,
      saveThrottleMs: 100,
      idleCallbackMaxWaitMs: 100,
      // Don't GC the kv store
      gc: null
    }), this.kv.onKeyLoaded = (n) => {
      n === "pendingMutations" && this.notifyAll();
    }, this.kv.waitForKeyToLoad("pendingMutations"), this.kv.waitForKeyToLoad(De), this._beforeUnloadCbs.push(() => {
      this.kv.flush(), this.querySubs.flush();
    });
  }
  _beforeUnload() {
    for (const e of this._beforeUnloadCbs)
      e();
    this._syncTable.beforeUnload();
  }
  /**
   * @param {'enqueued' | 'pending' | 'synced' | 'timeout' |  'error' } status
   * @param {string} eventId
   * @param {{message?: string, type?: string, status?: number, hint?: unknown}} [errorMsg]
   */
  _finishTransaction(e, n, r) {
    const i = this.mutationDeferredStore.get(n);
    this.mutationDeferredStore.delete(n);
    const s = e !== "error" && e !== "timeout";
    if (!i && !s && console.error("Mutation failed", Object.assign({ status: e, eventId: n }, r)), !!i)
      if (s)
        i.resolve({ status: e, eventId: n });
      else if (r != null && r.type) {
        const { status: o } = r, u = Wu(r, ["status"]);
        i.reject(new bt({
          // @ts-expect-error body.type is not constant typed
          body: u,
          status: o ?? 0
        }));
      } else
        i.reject(new je((r == null ? void 0 : r.message) || "Unknown error", r == null ? void 0 : r.hint));
  }
  _setStatus(e, n) {
    this.status = e, this._errorMessage = n, this.notifyConnectionStatusSubs(e);
  }
  _flushEnqueuedRoomData(e) {
    var n, r;
    const i = (r = (n = this._presence[e]) === null || n === void 0 ? void 0 : n.result) === null || r === void 0 ? void 0 : r.user, s = this._broadcastQueue[e];
    if (this._broadcastQueue[e] = [], i && this._trySetPresence(e, i), s)
      for (const o of s) {
        const { topic: u, roomType: a, data: d } = o;
        this._tryBroadcast(e, a, u, d);
      }
  }
  _handleReceive(e, n) {
    var r, i, s, o, u, a;
    const d = !!this.config.schema && ("cardinalityInference" in this.config ? !!this.config.cardinalityInference : !0);
    switch (gr[n.op] || this._log.info("[receive]", e, n.op, n), n.op) {
      case "init-ok": {
        this._setStatus(se.AUTHENTICATED), this._reconnectTimeoutMs = 0, this._setAttrs(n.attrs), this._flushPendingMessages(), this._sessionId = n["session-id"];
        for (const l of Object.keys(this._rooms)) {
          const p = (i = (r = this._presence[l]) === null || r === void 0 ? void 0 : r.result) === null || i === void 0 ? void 0 : i.user;
          this._tryJoinRoom(l, p);
        }
        break;
      }
      case "add-query-exists": {
        this.notifyOneQueryOnce(N(n.q));
        break;
      }
      case "add-query-ok": {
        const { q: l, result: p } = n, y = N(l);
        if (!this._hasQueryListeners() && !this.querySubs.currentValue[y])
          break;
        const b = (o = (s = p == null ? void 0 : p[0]) === null || s === void 0 ? void 0 : s.data) === null || o === void 0 ? void 0 : o["page-info"], g = (a = (u = p == null ? void 0 : p[0]) === null || u === void 0 ? void 0 : u.data) === null || a === void 0 ? void 0 : a.aggregate, m = or(p), T = at(this.attrs, m, d, this._linkIndex, this.config.useDateObjects);
        this.querySubs.updateInPlace((v) => {
          if (!v[y]) {
            this._log.info("Missing value in querySubs", { hash: y, q: l });
            return;
          }
          v[y].result = {
            store: T,
            pageInfo: b,
            aggregate: g,
            processedTxId: n["processed-tx-id"]
          };
        }), this._cleanupPendingMutationsQueries(), this.notifyOne(y), this.notifyOneQueryOnce(y), this._cleanupPendingMutationsTimeout();
        break;
      }
      case "start-sync-ok": {
        this._syncTable.onStartSyncOk(n);
        break;
      }
      case "sync-load-batch": {
        this._syncTable.onSyncLoadBatch(n);
        break;
      }
      case "sync-init-finish": {
        this._syncTable.onSyncInitFinish(n);
        break;
      }
      case "sync-update-triples": {
        this._syncTable.onSyncUpdateTriples(n);
        break;
      }
      case "refresh-ok": {
        const { computations: l, attrs: p } = n, y = n["processed-tx-id"];
        p && this._setAttrs(p), this._cleanupPendingMutationsTimeout();
        const b = this._rewriteMutations(this.attrs, this._pendingMutations(), y);
        b !== this._pendingMutations() && this.kv.updateInPlace((T) => {
          T.pendingMutations = b;
        });
        const g = Tr(b.entries()), m = l.map((T) => {
          var v, k, S, I;
          const R = T["instaql-query"], q = T["instaql-result"], Ie = N(R), Qe = or(q), _t = at(this.attrs, Qe, d, this._linkIndex, this.config.useDateObjects), gt = this._applyOptimisticUpdates(_t, g, y), He = (k = (v = q == null ? void 0 : q[0]) === null || v === void 0 ? void 0 : v.data) === null || k === void 0 ? void 0 : k["page-info"], ne = (I = (S = q == null ? void 0 : q[0]) === null || S === void 0 ? void 0 : S.data) === null || I === void 0 ? void 0 : I.aggregate;
          return { q: R, hash: Ie, store: gt, pageInfo: He, aggregate: ne };
        });
        m.forEach(({ hash: T, q: v, store: k, pageInfo: S, aggregate: I }) => {
          this.querySubs.updateInPlace((R) => {
            if (!R[T]) {
              this._log.error("Missing value in querySubs", { hash: T, q: v });
              return;
            }
            R[T].result = { store: k, pageInfo: S, aggregate: I, processedTxId: y };
          });
        }), this._cleanupPendingMutationsQueries(), m.forEach(({ hash: T }) => {
          this.notifyOne(T);
        });
        break;
      }
      case "transact-ok": {
        const { "client-event-id": l, "tx-id": p } = n;
        this._inFlightMutationEventIds.delete(l);
        const b = this._rewriteMutations(this.attrs, this._pendingMutations()).get(l);
        if (!b)
          break;
        this._updatePendingMutations((m) => {
          m.set(l, Object.assign(Object.assign({}, m.get(l)), { "tx-id": p, confirmed: Date.now() }));
        });
        const g = b["tx-steps"].filter(([m, ...T]) => m === "add-attr").map(([m, T]) => T).concat(Object.values(this.attrs));
        this._setAttrs(g), this._finishTransaction("synced", l), this._cleanupPendingMutationsTimeout();
        break;
      }
      case "patch-presence": {
        const l = n["room-id"];
        this._trySetRoomConnected(l, !0), this._patchPresencePeers(l, n.edits), this._notifyPresenceSubs(l);
        break;
      }
      case "refresh-presence": {
        const l = n["room-id"];
        this._trySetRoomConnected(l, !0), this._setPresencePeers(l, n.data), this._notifyPresenceSubs(l);
        break;
      }
      case "server-broadcast": {
        const l = n["room-id"], p = n.topic;
        this._trySetRoomConnected(l, !0), this._notifyBroadcastSubs(l, p, n);
        break;
      }
      case "join-room-ok": {
        const l = n["room-id"];
        if (!this._rooms[l]) {
          this._roomsPendingLeave[l] && (this._tryLeaveRoom(l), delete this._roomsPendingLeave[l]);
          break;
        }
        this._trySetRoomConnected(l, !0), this._flushEnqueuedRoomData(l);
        break;
      }
      case "leave-room-ok": {
        const l = n["room-id"];
        this._trySetRoomConnected(l, !1);
        break;
      }
      case "join-room-error":
        const c = n["room-id"], f = this._rooms[c];
        f && (f.error = n.error), this._notifyPresenceSubs(c);
        break;
      case "error":
        this._handleReceiveError(n);
        break;
      default:
        this._log.info("Uknown op", n.op, n);
        break;
    }
  }
  _pendingMutations() {
    var e;
    return (e = this.kv.currentValue.pendingMutations) !== null && e !== void 0 ? e : /* @__PURE__ */ new Map();
  }
  _updatePendingMutations(e) {
    this.kv.updateInPlace((n) => {
      var r;
      const i = (r = n.pendingMutations) !== null && r !== void 0 ? r : /* @__PURE__ */ new Map();
      n.pendingMutations = i, e(i);
    });
  }
  /**
   * @param {'timeout' | 'error'} status
   * @param {string} eventId
   * @param {{message?: string, type?: string, status?: number, hint?: unknown}} errorMsg
   */
  _handleMutationError(e, n, r) {
    const i = this._pendingMutations().get(n);
    if (i && (e !== "timeout" || !i["tx-id"])) {
      this._updatePendingMutations((o) => (o.delete(n), o)), this._inFlightMutationEventIds.delete(n);
      const s = {
        message: r.message,
        hint: r.hint
      };
      this.notifyAll(), this.notifyAttrsSubs(), this.notifyMutationErrorSubs(s), this._finishTransaction(e, n, r);
    }
  }
  _handleReceiveError(e) {
    var n, r, i, s, o, u, a;
    console.log("error", e);
    const d = e["client-event-id"];
    this._inFlightMutationEventIds.delete(d);
    const c = this._pendingMutations().get(d), f = {
      message: e.message || "Uh-oh, something went wrong. Ping Joe & Stopa."
    };
    if (e.hint && (f.hint = e.hint), c) {
      this._handleMutationError("error", d, e);
      return;
    }
    if (!((n = e["original-event"]) === null || n === void 0) && n.hasOwnProperty("q") && ((r = e["original-event"]) === null || r === void 0 ? void 0 : r.op) === "add-query") {
      const y = (i = e["original-event"]) === null || i === void 0 ? void 0 : i.q, b = N(y);
      this.notifyQueryError(N(y), f), this.notifyQueryOnceError(y, b, d, f);
      return;
    }
    if (((s = e["original-event"]) === null || s === void 0 ? void 0 : s.op) === "init") {
      if (e.type === "record-not-found" && ((o = e.hint) === null || o === void 0 ? void 0 : o["record-type"]) === "app-user") {
        this.changeCurrentUser(null);
        return;
      }
      this._setStatus(se.ERRORED, f), this.notifyAll();
      return;
    }
    if (((u = e["original-event"]) === null || u === void 0 ? void 0 : u.op) === "resync-table") {
      this._syncTable.onResyncError(e);
      return;
    }
    if (((a = e["original-event"]) === null || a === void 0 ? void 0 : a.op) === "start-sync") {
      this._syncTable.onStartSyncError(e);
      return;
    }
    const p = Object.assign({}, e);
    delete p.message, delete p.hint, console.error(e.message, p), e.hint && console.error(`This error comes with some debugging information. Here it is: 
`, e.hint);
  }
  notifyQueryOnceError(e, n, r, i) {
    var s;
    const o = (s = this.queryOnceDfds[n]) === null || s === void 0 ? void 0 : s.find((u) => u.eventId === r);
    o && (o.dfd.reject(i), this._completeQueryOnce(e, n, o.dfd));
  }
  _setAttrs(e) {
    this.attrs = e.reduce((n, r) => (n[r.id] = r, n), {}), this.notifyAttrsSubs();
  }
  _startQuerySub(e, n) {
    const r = L();
    return this.querySubs.updateInPlace((i) => {
      i[n] = i[n] || { q: e, result: null, eventId: r }, i[n].lastAccessed = Date.now();
    }), this._trySendAuthed(r, { op: "add-query", q: e }), r;
  }
  subscribeTable(e, n) {
    return this._syncTable.subscribe(e, n);
  }
  /**
   *  When a user subscribes to a query the following side effects occur:
   *
   *  - We update querySubs to include the new query
   *  - We update queryCbs to include the new cb
   *  - If we already have a result for the query we call cb immediately
   *  - We send the server an `add-query` message
   *
   *  Returns an unsubscribe function
   */
  subscribeQuery(e, n, r) {
    var i;
    this.config.disableValidation || cr(e, this.config.schema), r && "ruleParams" in r && (e = Object.assign({ $$ruleParams: r.ruleParams }, e));
    const s = N(e), o = this.getPreviousResult(e);
    return o && n(o), this.queryCbs[s] = (i = this.queryCbs[s]) !== null && i !== void 0 ? i : [], this.queryCbs[s].push({ q: e, cb: n }), this._startQuerySub(e, s), () => {
      this._unsubQuery(e, s, n);
    };
  }
  queryOnce(e, n) {
    var r;
    this.config.disableValidation || cr(e, this.config.schema), n && "ruleParams" in n && (e = Object.assign({ $$ruleParams: n.ruleParams }, e));
    const i = new sr();
    if (!this._isOnline)
      return i.reject(new Error("We can't run `queryOnce`, because the device is offline.")), i.promise;
    if (!this.querySubs)
      return i.reject(new Error("We can't run `queryOnce` on the backend. Use adminAPI.query instead: https://www.instantdb.com/docs/backend#query")), i.promise;
    const s = N(e), o = this._startQuerySub(e, s);
    return this.queryOnceDfds[s] = (r = this.queryOnceDfds[s]) !== null && r !== void 0 ? r : [], this.queryOnceDfds[s].push({ q: e, dfd: i, eventId: o }), setTimeout(() => i.reject(new Error("Query timed out")), Bu), i.promise;
  }
  _completeQueryOnce(e, n, r) {
    this.queryOnceDfds[n] && (this.queryOnceDfds[n] = this.queryOnceDfds[n].filter((i) => i.dfd !== r), this._cleanupQuery(e, n));
  }
  _unsubQuery(e, n, r) {
    this.queryCbs[n] && (this.queryCbs[n] = this.queryCbs[n].filter((i) => i.cb !== r), this._cleanupQuery(e, n));
  }
  _hasQueryListeners(e) {
    var n, r;
    return !!(!((n = this.queryCbs[e]) === null || n === void 0) && n.length || !((r = this.queryOnceDfds[e]) === null || r === void 0) && r.length);
  }
  _cleanupQuery(e, n) {
    this._hasQueryListeners(n) || (delete this.queryCbs[n], delete this.queryOnceDfds[n], delete this._dataForQueryCache[n], this.querySubs.unloadKey(n), this._trySendAuthed(L(), { op: "remove-query", q: e }));
  }
  // When we `pushTx`, it's possible that we don't yet have `this.attrs`
  // This means that `tx-steps` in `pendingMutations` will include `add-attr`
  // commands for attrs that already exist.
  //
  // This will also affect `add-triple` and `retract-triple` which
  // reference attr-ids that do not match the server.
  //
  // We fix this by rewriting `tx-steps` in each `pendingMutation`.
  // We remove `add-attr` commands for attrs that already exist.
  // We update `add-triple` and `retract-triple` commands to use the
  // server attr-ids.
  _rewriteMutations(e, n, r) {
    if (!e)
      return n;
    if (!n)
      return /* @__PURE__ */ new Map();
    const i = (c) => {
      const [f, l, p] = c["forward-identity"];
      return K(e, l, p);
    }, s = (c) => {
      const [f, l, p] = c["forward-identity"];
      return _e(e, l, p);
    }, o = { attrIdMap: {}, refSwapAttrIds: /* @__PURE__ */ new Set() };
    let u = !1;
    const a = (c, f) => {
      const l = [];
      for (const p of c) {
        const [y] = p;
        if (y === "add-attr") {
          const [g, m] = p, T = i(m);
          if (T && m.id !== T.id) {
            o.attrIdMap[m.id] = T.id, u = !0;
            continue;
          }
          if (m["value-type"] === "ref") {
            const v = s(m);
            if (v) {
              o.attrIdMap[m.id] = v.id, o.refSwapAttrIds.add(m.id), u = !0;
              continue;
            }
          }
        }
        if (r && f && r >= f && y === "add-attr" || y === "update-attr" || y === "delete-attr") {
          u = !0;
          continue;
        }
        const b = u ? $o(o, p) : p;
        l.push(b);
      }
      return u ? l : c;
    }, d = /* @__PURE__ */ new Map();
    for (const [c, f] of n.entries())
      d.set(c, Object.assign(Object.assign({}, f), { "tx-steps": a(f["tx-steps"], f["tx-id"]) }));
    return u ? d : n;
  }
  _rewriteMutationsSorted(e, n) {
    return Tr(this._rewriteMutations(e, n).entries());
  }
  // ---------------------------
  // Transact
  optimisticAttrs() {
    var e;
    const n = [...this._pendingMutations().values()].flatMap((u) => u["tx-steps"]), r = new Set(n.filter(([u, a]) => u === "delete-attr").map(([u, a]) => a)), i = [];
    for (const [u, a] of n)
      if (u === "add-attr")
        i.push(a);
      else if (u === "update-attr" && a.id && (!((e = this.attrs) === null || e === void 0) && e[a.id])) {
        const d = Object.assign(Object.assign({}, this.attrs[a.id]), a);
        i.push(d);
      }
    const s = [
      ...Object.values(this.attrs || {}),
      ...i
    ].filter((u) => !r.has(u.id));
    return Object.fromEntries(s.map((u) => [u.id, u]));
  }
  /** Runs instaql on a query and a store */
  dataForQuery(e) {
    const n = this._errorMessage;
    if (n)
      return { error: n };
    if (!this.querySubs || !this.kv.currentValue.pendingMutations)
      return;
    const r = this.querySubs.version(), i = this.querySubs.currentValue, s = this.kv.version(), o = this._pendingMutations(), { q: u, result: a } = i[e] || {};
    if (!a)
      return;
    const d = this._dataForQueryCache[e];
    if (d && r === d.querySubVersion && s === d.pendingMutationsVersion)
      return d;
    const { store: c, pageInfo: f, aggregate: l, processedTxId: p } = a, y = this._rewriteMutationsSorted(c.attrs, o), b = this._applyOptimisticUpdates(c, y, p);
    return { data: Jr({ store: b, pageInfo: f, aggregate: l }, u), querySubVersion: r, pendingMutationsVersion: s };
  }
  _applyOptimisticUpdates(e, n, r) {
    for (const [i, s] of n)
      (!s["tx-id"] || r && s["tx-id"] > r) && (e = $s(e, s["tx-steps"]));
    return e;
  }
  /** Re-compute all subscriptions */
  notifyAll() {
    Object.keys(this.queryCbs).forEach((e) => {
      this.querySubs.waitForKeyToLoad(e).then(() => this.notifyOne(e)).catch(() => this.notifyOne(e));
    });
  }
  loadedNotifyAll() {
    this.kv.waitForKeyToLoad("pendingMutations").then(() => this.notifyAll()).catch(() => this.notifyAll());
  }
  shutdown() {
    var e;
    this._log.info("[shutdown]", this.config.appId), this._isShutdown = !0, (e = this._transport) === null || e === void 0 || e.close();
  }
  /**
   * Sends mutation to server and schedules a timeout to cancel it if
   * we don't hear back in time.
   * Note: If we're offline we don't schedule a timeout, we'll schedule it
   * later once we're back online and send the mutation again
   *
   */
  _sendMutation(e, n) {
    if (n.error) {
      this._handleMutationError("error", e, {
        message: n.error.message
      });
      return;
    }
    if (this.status !== se.AUTHENTICATED) {
      this._finishTransaction("enqueued", e);
      return;
    }
    const r = Math.max(6e3, Math.min(
      this._inFlightMutationEventIds.size + 1,
      // Defensive code in case we don't clean up in flight mutation event ids
      this._pendingMutations().size + 1
    ) * 6e3);
    this._isOnline ? (this._trySend(e, n), setTimeout(() => {
      this._isOnline && this._handleMutationError("timeout", e, {
        message: "transaction timed out"
      });
    }, r)) : this._finishTransaction("enqueued", e);
  }
  // ---------------------------
  // Websocket
  /** Send messages we accumulated while we were connecting */
  _flushPendingMessages() {
    Object.keys(this.queryCbs).map((i) => this.querySubs.currentValue[i]).filter((i) => i).forEach(({ eventId: i, q: s }) => {
      this._trySendAuthed(i, { op: "add-query", q: s });
    }), Object.values(this.queryOnceDfds).flat().forEach(({ eventId: i, q: s }) => {
      this._trySendAuthed(i, { op: "add-query", q: s });
    }), this._rewriteMutationsSorted(this.attrs, this._pendingMutations()).forEach(([i, s]) => {
      s["tx-id"] || this._sendMutation(i, s);
    }), this._syncTable.flushPending();
  }
  /**
   * Clean up pendingMutations that all queries have seen
   */
  _cleanupPendingMutationsQueries() {
    let e = Number.MAX_SAFE_INTEGER;
    for (const { result: n } of Object.values(this.querySubs.currentValue))
      n != null && n.processedTxId && (e = Math.min(e, n == null ? void 0 : n.processedTxId));
    this._updatePendingMutations((n) => {
      for (const [r, i] of Array.from(n.entries()))
        i["tx-id"] && i["tx-id"] <= e && n.delete(r);
    });
  }
  /**
   * After mutations is confirmed by server, we give each query 30 sec
   * to update its results. If that doesn't happen, we assume query is
   * unaffected by this mutation and its safe to delete it from local queue
   */
  _cleanupPendingMutationsTimeout() {
    if (this._pendingMutations().size < this._pendingMutationCleanupThreshold)
      return;
    const e = Date.now();
    this._updatePendingMutations((n) => {
      for (const [r, i] of Array.from(n.entries()))
        i.confirmed && i.confirmed + this._pendingTxCleanupTimeout < e && n.delete(r);
    });
  }
  _trySendAuthed(...e) {
    this.status === se.AUTHENTICATED && this._trySend(...e);
  }
  _trySend(e, n, r) {
    if (this._transport.isOpen()) {
      switch (gr[n.op] || this._log.info("[send]", this._transport.id, n.op, n), n.op) {
        case "transact": {
          this._inFlightMutationEventIds.add(e);
          break;
        }
        case "init":
          this._inFlightMutationEventIds.clear();
      }
      this._transport.send(Object.assign({ "client-event-id": e }, n));
    }
  }
  _startSocket() {
    if (this._wsOk = null, this._isShutdown) {
      this._log.info("[socket][start]", this.config.appId, "Reactor has been shut down and will not start a new socket");
      return;
    }
    if (this._transport && this._transport.isConnecting()) {
      this._log.info("[socket][start]", this._transport.id, "maintained as current transport, we were still in a connecting state");
      return;
    }
    const e = this._transport;
    this._transport = Yu({
      transportType: this._transportType,
      appId: this.config.appId,
      apiURI: this.config.apiURI,
      wsURI: this.config.websocketURI,
      EventSourceImpl: this._EventSource
    }), this._transport.onopen = this._transportOnOpen, this._transport.onmessage = this._transportOnMessage, this._transport.onclose = this._transportOnClose, this._transport.onerror = this._transportOnError, this._log.info("[socket][start]", this._transport.id), e != null && e.isOpen() && (this._log.info("[socket][start]", this._transport.id, "close previous transport id = ", e.id), e.close());
  }
  /**
   * Given a key, returns a stable local id, unique to this device and app.
   *
   * This can be useful if you want to create guest ids for example.
   *
   * Note: If the user deletes their local storage, this id will change.
   *
   */
  getLocalId(e) {
    return U(this, void 0, void 0, function* () {
      const n = `localToken_${e}`;
      if (this.kv.currentValue[n])
        return this.kv.currentValue[n];
      const r = yield this.kv.waitForKeyToLoad(n);
      if (r)
        return r;
      const i = L();
      return this.kv.updateInPlace((s) => {
        s[n] || (s[n] = i);
      }), yield this.kv.waitForKeyToLoad(n);
    });
  }
  // ----
  // Auth
  _replaceUrlAfterOAuth() {
    if (typeof URL > "u")
      return;
    const e = new URL(window.location.href);
    if (e.searchParams.get(It)) {
      const n = e.toString();
      e.searchParams.delete(It), e.searchParams.delete("code"), e.searchParams.delete("error");
      const r = e.pathname + (e.searchParams.size ? "?" + e.searchParams : "") + e.hash;
      if (history.replaceState(history.state, "", r), // @ts-ignore (waiting for ts support)
      typeof navigation == "object" && // @ts-ignore (waiting for ts support)
      typeof navigation.addEventListener == "function" && // @ts-ignore (waiting for ts support)
      typeof navigation.removeEventListener == "function") {
        let i = !1;
        const s = (o) => {
          var u;
          i || (i = !0, navigation.removeEventListener("navigate", s), !o.userInitiated && o.navigationType === "replace" && ((u = o.destination) === null || u === void 0 ? void 0 : u.url) === n && history.replaceState(history.state, "", r));
        };
        navigation.addEventListener("navigate", s);
      }
    }
  }
  /**
   *
   * @returns Promise<null | {error: {message: string}}>
   */
  _oauthLoginInit() {
    return U(this, void 0, void 0, function* () {
      var e, n, r, i;
      if (typeof window > "u" || typeof window.location > "u" || typeof URLSearchParams > "u")
        return null;
      const s = new URLSearchParams(window.location.search);
      if (!s.get(It))
        return null;
      const o = s.get("error");
      if (o)
        return this._replaceUrlAfterOAuth(), { error: { message: o } };
      const u = s.get("code");
      if (!u)
        return null;
      this._replaceUrlAfterOAuth();
      try {
        const a = yield this._getCurrentUser(), d = (a == null ? void 0 : a.type) === "guest", { user: c } = yield rr({
          apiURI: this.config.apiURI,
          appId: this.config.appId,
          code: u,
          refreshToken: d ? a.refresh_token : void 0
        });
        return this.setCurrentUser(c), null;
      } catch (a) {
        return ((e = a == null ? void 0 : a.body) === null || e === void 0 ? void 0 : e.type) === "record-not-found" && ((r = (n = a == null ? void 0 : a.body) === null || n === void 0 ? void 0 : n.hint) === null || r === void 0 ? void 0 : r["record-type"]) === "app-oauth-code" && (yield this._hasCurrentUser()) ? null : { error: { message: ((i = a == null ? void 0 : a.body) === null || i === void 0 ? void 0 : i.message) || "Error logging in." } };
      }
    });
  }
  _waitForOAuthCallbackResponse() {
    return U(this, void 0, void 0, function* () {
      return yield this._oauthCallbackResponse;
    });
  }
  __subscribeMutationErrors(e) {
    return this.mutationErrorCbs.push(e), () => {
      this.mutationErrorCbs = this.mutationErrorCbs.filter((n) => n !== e);
    };
  }
  subscribeAuth(e) {
    this.authCbs.push(e);
    const n = this._currentUserCached;
    n.isLoading || e(this._currentUserCached);
    let r = !1;
    return this.getCurrentUser().then((i) => {
      r || ut(i, n) || e(i);
    }), () => {
      r = !0, this.authCbs = this.authCbs.filter((i) => i !== e);
    };
  }
  getAuth() {
    return U(this, void 0, void 0, function* () {
      const { user: e, error: n } = yield this.getCurrentUser();
      if (n)
        throw new je("Could not get current user: " + n.message);
      return e;
    });
  }
  subscribeConnectionStatus(e) {
    return this.connectionStatusCbs.push(e), () => {
      this.connectionStatusCbs = this.connectionStatusCbs.filter((n) => n !== e);
    };
  }
  subscribeAttrs(e) {
    return this.attrsCbs.push(e), this.attrs && e(this.attrs), () => {
      this.attrsCbs = this.attrsCbs.filter((n) => n !== e);
    };
  }
  notifyAuthSubs(e) {
    this.authCbs.forEach((n) => n(e));
  }
  notifyMutationErrorSubs(e) {
    this.mutationErrorCbs.forEach((n) => n(e));
  }
  notifyAttrsSubs() {
    if (!this.attrs)
      return;
    const e = this.optimisticAttrs();
    this.attrsCbs.forEach((n) => n(e));
  }
  notifyConnectionStatusSubs(e) {
    this.connectionStatusCbs.forEach((n) => n(e));
  }
  setCurrentUser(e) {
    return U(this, void 0, void 0, function* () {
      this.kv.updateInPlace((n) => {
        n[De] = e;
      }), yield this.kv.waitForKeyToLoad(De);
    });
  }
  getCurrentUserCached() {
    return this._currentUserCached;
  }
  _getCurrentUser() {
    return U(this, void 0, void 0, function* () {
      const e = yield this.kv.waitForKeyToLoad(De);
      return typeof e == "string" ? JSON.parse(e) : e;
    });
  }
  getCurrentUser() {
    return U(this, void 0, void 0, function* () {
      const e = yield this._waitForOAuthCallbackResponse();
      if (e != null && e.error) {
        const n = { error: e.error, user: void 0 };
        return this._currentUserCached = Object.assign({ isLoading: !1 }, n), n;
      }
      try {
        const r = { user: yield this._getCurrentUser(), error: void 0 };
        return this._currentUserCached = Object.assign({ isLoading: !1 }, r), r;
      } catch (n) {
        return {
          user: void 0,
          isLoading: !1,
          error: { message: (n == null ? void 0 : n.message) || "Error loading user" }
        };
      }
    });
  }
  _hasCurrentUser() {
    return U(this, void 0, void 0, function* () {
      const e = yield this.kv.waitForKeyToLoad(De);
      return typeof e == "string" ? JSON.parse(e) != null : e != null;
    });
  }
  changeCurrentUser(e) {
    return U(this, void 0, void 0, function* () {
      var n;
      const { user: r } = yield this.getCurrentUser();
      if (!ut(r, e)) {
        yield this.setCurrentUser(e), this.updateUser(e);
        try {
          (n = this._broadcastChannel) === null || n === void 0 || n.postMessage({ type: "auth" });
        } catch (i) {
          console.error("Error posting message to broadcast channel", i);
        }
      }
    });
  }
  updateUser(e) {
    const n = { error: void 0, user: e };
    this._currentUserCached = Object.assign({ isLoading: !1 }, n), this._dataForQueryCache = {}, this.querySubs.updateInPlace((r) => {
      Object.keys(r).forEach((i) => {
        delete r[i].result;
      });
    }), this._reconnectTimeoutMs = 0, this._transport.close(), this._oauthCallbackResponse = null, this.notifyAuthSubs(n);
  }
  sendMagicCode({ email: e }) {
    return pu({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      email: e
    });
  }
  signInWithMagicCode(e) {
    return U(this, arguments, void 0, function* ({ email: n, code: r }) {
      var i;
      const s = yield this.getCurrentUser(), o = ((i = s == null ? void 0 : s.user) === null || i === void 0 ? void 0 : i.type) === "guest", u = yield yu({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        email: n,
        code: r,
        refreshToken: o ? s.user.refresh_token : void 0
      });
      return yield this.changeCurrentUser(u.user), u;
    });
  }
  signInWithCustomToken(e) {
    return U(this, void 0, void 0, function* () {
      const n = yield bu({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        refreshToken: e
      });
      return yield this.changeCurrentUser(n.user), n;
    });
  }
  signInAsGuest() {
    return U(this, void 0, void 0, function* () {
      const e = yield _u({
        apiURI: this.config.apiURI,
        appId: this.config.appId
      });
      return yield this.changeCurrentUser(e.user), e;
    });
  }
  potentiallyInvalidateToken(e, n) {
    var r;
    const i = (r = e == null ? void 0 : e.user) === null || r === void 0 ? void 0 : r.refresh_token;
    if (!i)
      return;
    if (n.invalidateToken === !1) {
      this._log.info("[auth-invalidate] skipped invalidateToken");
      return;
    }
    Tu({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      refreshToken: i
    }).then(() => {
      this._log.info("[auth-invalidate] completed invalidateToken");
    }).catch((o) => {
    });
  }
  signOut(e) {
    return U(this, void 0, void 0, function* () {
      const n = yield this.getCurrentUser();
      this.potentiallyInvalidateToken(n, e), yield this.changeCurrentUser(null);
    });
  }
  /**
   * Creates an OAuth authorization URL.
   *
   * @param {Object} params - The parameters to create the authorization URL.
   * @param {string} params.clientName - The name of the client requesting authorization.
   * @param {string} params.redirectURL - The URL to redirect users to after authorization.
   * @returns {string} The created authorization URL.
   */
  createAuthorizationURL({ clientName: e, redirectURL: n }) {
    const { apiURI: r, appId: i } = this.config;
    return `${r}/runtime/oauth/start?app_id=${i}&client_name=${e}&redirect_uri=${n}`;
  }
  /**
   * @param {Object} params
   * @param {string} params.code - The code received from the OAuth service.
   * @param {string} [params.codeVerifier] - The code verifier used to generate the code challenge.
   */
  exchangeCodeForToken(e) {
    return U(this, arguments, void 0, function* ({ code: n, codeVerifier: r }) {
      var i;
      const s = yield this.getCurrentUser(), o = ((i = s == null ? void 0 : s.user) === null || i === void 0 ? void 0 : i.type) === "guest", u = yield rr({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        code: n,
        codeVerifier: r,
        refreshToken: o ? s.user.refresh_token : void 0
      });
      return yield this.changeCurrentUser(u.user), u;
    });
  }
  issuerURI() {
    const { apiURI: e, appId: n } = this.config;
    return `${e}/runtime/${n}`;
  }
  /**
   * @param {Object} params
   * @param {string} params.clientName - The name of the client requesting authorization.
   * @param {string} params.idToken - The id_token from the external service
   * @param {string | null | undefined} [params.nonce] - The nonce used when requesting the id_token from the external service
   */
  signInWithIdToken(e) {
    return U(this, arguments, void 0, function* ({ idToken: n, clientName: r, nonce: i }) {
      var s;
      const o = yield this.getCurrentUser(), u = (s = o == null ? void 0 : o.user) === null || s === void 0 ? void 0 : s.refresh_token, a = yield gu({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        idToken: n,
        clientName: r,
        nonce: i,
        refreshToken: u
      });
      return yield this.changeCurrentUser(a.user), a;
    });
  }
  // --------
  // Rooms
  /**
   * @param {string} roomId
   * @param {any | null | undefined} [initialPresence] -- initial presence data to send when joining the room
   * @returns () => void
   */
  joinRoom(e, n) {
    let r = !1;
    this._rooms[e] || (r = !0, this._rooms[e] = {
      isConnected: !1,
      error: void 0
    }), this._presence[e] = this._presence[e] || {};
    const i = this._presence[e].result;
    return n && !i && (this._presence[e].result = this._presence[e].result || {}, this._presence[e].result.user = n, this._notifyPresenceSubs(e)), r && this._tryJoinRoom(e, n), () => {
      this._cleanupRoom(e);
    };
  }
  _cleanupRoom(e) {
    var n, r, i, s;
    if (!(!((r = (n = this._presence[e]) === null || n === void 0 ? void 0 : n.handlers) === null || r === void 0) && r.length) && !Object.keys((i = this._broadcastSubs[e]) !== null && i !== void 0 ? i : {}).length) {
      const o = (s = this._rooms[e]) === null || s === void 0 ? void 0 : s.isConnected;
      delete this._rooms[e], delete this._presence[e], delete this._broadcastSubs[e], o ? this._tryLeaveRoom(e) : this._roomsPendingLeave[e] = !0;
    }
  }
  // --------
  // Presence
  // TODO: look into typing again
  getPresence(e, n, r = {}) {
    const i = this._rooms[n], s = this._presence[n];
    return !i || !s || !s.result ? null : Object.assign(Object.assign({}, Eu(s.result, r, this._sessionId)), { isLoading: !i.isConnected, error: i.error });
  }
  // TODO: look into typing again
  publishPresence(e, n, r) {
    const i = this._rooms[n], s = this._presence[n];
    if (!i || !s)
      return;
    s.result = s.result || {};
    const o = Object.assign(Object.assign({}, s.result.user), r);
    s.result.user = o, i.isConnected && (this._trySetPresence(n, o), this._notifyPresenceSubs(n));
  }
  _trySetPresence(e, n) {
    this._trySendAuthed(L(), {
      op: "set-presence",
      "room-id": e,
      data: n
    });
  }
  _tryJoinRoom(e, n) {
    this._trySendAuthed(L(), { op: "join-room", "room-id": e, data: n }), delete this._roomsPendingLeave[e];
  }
  _tryLeaveRoom(e) {
    this._trySendAuthed(L(), { op: "leave-room", "room-id": e });
  }
  _trySetRoomConnected(e, n) {
    const r = this._rooms[e];
    r && (r.isConnected = n);
  }
  // TODO: look into typing again
  subscribePresence(e, n, r, i) {
    const s = this.joinRoom(
      n,
      // Oct 28, 2025
      // Note: initialData is deprecated.
      // Keeping here for backwards compatibility
      r.initialPresence || r.initialData
    ), o = Object.assign(Object.assign({}, r), { roomId: n, cb: i, prev: null });
    return this._presence[n] = this._presence[n] || {}, this._presence[n].handlers = this._presence[n].handlers || [], this._presence[n].handlers.push(o), this._notifyPresenceSub(n, o), () => {
      var u, a, d;
      this._presence[n].handlers = (d = (a = (u = this._presence[n]) === null || u === void 0 ? void 0 : u.handlers) === null || a === void 0 ? void 0 : a.filter((c) => c !== o)) !== null && d !== void 0 ? d : [], s();
    };
  }
  _notifyPresenceSubs(e) {
    var n, r;
    (r = (n = this._presence[e]) === null || n === void 0 ? void 0 : n.handlers) === null || r === void 0 || r.forEach((i) => {
      this._notifyPresenceSub(e, i);
    });
  }
  _notifyPresenceSub(e, n) {
    const r = this.getPresence("", e, n);
    r && (n.prev && !Au(r, n.prev) || (n.prev = r, n.cb(r)));
  }
  _patchPresencePeers(e, n) {
    var r, i, s;
    const o = ((i = (r = this._presence[e]) === null || r === void 0 ? void 0 : r.result) === null || i === void 0 ? void 0 : i.peers) || {};
    let u = Object.fromEntries(Object.entries(o).map(([d, c]) => [d, { data: c }]));
    (s = this._presence[e]) === null || s === void 0 || s.result;
    const a = ft(u, (d) => {
      for (let [c, f, l] of n)
        switch (f) {
          case "+":
            ns(d, c, l);
            break;
          case "r":
            Vn(d, c, l);
            break;
          case "-":
            $r(d, c);
            break;
        }
      delete d[this._sessionId];
    });
    this._setPresencePeers(e, a);
  }
  _setPresencePeers(e, n) {
    const r = Object.assign({}, n);
    delete r[this._sessionId];
    const i = Object.fromEntries(Object.entries(r).map(([s, o]) => [s, o.data]));
    this._presence = ft(this._presence, (s) => {
      Vn(s, [e, "result", "peers"], i);
    });
  }
  // --------
  // Broadcast
  publishTopic({ roomType: e, roomId: n, topic: r, data: i }) {
    var s;
    const o = this._rooms[n];
    if (o) {
      if (!o.isConnected) {
        this._broadcastQueue[n] = (s = this._broadcastQueue[n]) !== null && s !== void 0 ? s : [], this._broadcastQueue[n].push({ topic: r, roomType: e, data: i });
        return;
      }
      this._tryBroadcast(n, e, r, i);
    }
  }
  _tryBroadcast(e, n, r, i) {
    this._trySendAuthed(L(), {
      op: "client-broadcast",
      "room-id": e,
      roomType: n,
      topic: r,
      data: i
    });
  }
  subscribeTopic(e, n, r) {
    const i = this.joinRoom(e);
    return this._broadcastSubs[e] = this._broadcastSubs[e] || {}, this._broadcastSubs[e][n] = this._broadcastSubs[e][n] || [], this._broadcastSubs[e][n].push(r), this._presence[e] = this._presence[e] || {}, () => {
      this._broadcastSubs[e][n] = this._broadcastSubs[e][n].filter((s) => s !== r), this._broadcastSubs[e][n].length || delete this._broadcastSubs[e][n], i();
    };
  }
  _notifyBroadcastSubs(e, n, r) {
    var i, s, o;
    (o = (s = (i = this._broadcastSubs) === null || i === void 0 ? void 0 : i[e]) === null || s === void 0 ? void 0 : s[n]) === null || o === void 0 || o.forEach((u) => {
      var a, d, c, f, l, p;
      const y = (a = r.data) === null || a === void 0 ? void 0 : a.data, b = r.data["peer-id"] === this._sessionId ? (c = (d = this._presence[e]) === null || d === void 0 ? void 0 : d.result) === null || c === void 0 ? void 0 : c.user : (p = (l = (f = this._presence[e]) === null || f === void 0 ? void 0 : f.result) === null || l === void 0 ? void 0 : l.peers) === null || p === void 0 ? void 0 : p[r.data["peer-id"]];
      return u(y, b);
    });
  }
  // --------
  // Storage
  uploadFile(e, n, r) {
    return U(this, void 0, void 0, function* () {
      var i;
      const s = yield this.getCurrentUser(), o = (i = s == null ? void 0 : s.user) === null || i === void 0 ? void 0 : i.refresh_token;
      return mu(Object.assign(Object.assign({}, r), { apiURI: this.config.apiURI, appId: this.config.appId, path: e, file: n, refreshToken: o }));
    });
  }
  deleteFile(e) {
    return U(this, void 0, void 0, function* () {
      var n;
      const r = yield this.getCurrentUser(), i = (n = r == null ? void 0 : r.user) === null || n === void 0 ? void 0 : n.refresh_token;
      return yield wu({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        path: e,
        refreshToken: i
      });
    });
  }
  // Deprecated Storage API (Jan 2025)
  // ---------------------------------
  upload(e, n) {
    return U(this, void 0, void 0, function* () {
      var r;
      const i = yield this.getCurrentUser(), s = (r = i == null ? void 0 : i.user) === null || r === void 0 ? void 0 : r.refresh_token, o = e || n.name, u = yield vu({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        fileName: o,
        refreshToken: s
      });
      return yield Su(u, n);
    });
  }
  getDownloadUrl(e) {
    return U(this, void 0, void 0, function* () {
      var n;
      const r = yield this.getCurrentUser(), i = (n = r == null ? void 0 : r.user) === null || n === void 0 ? void 0 : n.refresh_token;
      return yield Ou({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        path: e,
        refreshToken: i
      });
    });
  }
}
let it;
function ia(t, e) {
  it == null || it.dispose();
  const n = da(e), r = ua(e, u), i = oa(sa(t));
  function s(c) {
    var f;
    c.source === i.element.contentWindow && ((f = c.data) === null || f === void 0 ? void 0 : f.type) === "close" && n.isVisible() && u();
  }
  function o(c) {
    const f = c.shiftKey && c.ctrlKey && c.key === "0", l = c.key === "Escape" || c.key === "Esc";
    (f || l && n.isVisible()) && u();
  }
  function u() {
    n.isVisible() ? n.element.style.display = "none" : (n.element.style.display = "block", n.element.contains(i.element) || n.element.appendChild(i.element));
  }
  function a() {
    n.element.remove(), r.element.remove(), removeEventListener("keydown", o), removeEventListener("message", s);
  }
  function d() {
    document.body.appendChild(n.element), document.body.appendChild(r.element), addEventListener("keydown", o), addEventListener("message", s), it = {
      dispose: a
    };
  }
  return d();
}
function sa(t) {
  return `${hn || ii ? "http://localhost:3000" : "https://instantdb.com"}/_devtool?appId=${t}`;
}
function oa(t) {
  const e = document.createElement("iframe");
  return e.src = t, e.className = "instant-devtool-iframe", Object.assign(e.style, {
    width: "100%",
    height: "100%",
    backgroundColor: "white",
    border: "none"
  }), { element: e };
}
function ua(t, e) {
  const n = `
    <svg width="32" height="32" viewBox="0 0 512 512" fill="none" xmlns="http://www.w3.org/2000/svg">
      <rect width="512" height="512" fill="black"/>
      <rect x="97.0973" y="91.3297" width="140" height="330" fill="white"/>
    </svg>
  `, r = document.createElement("button");
  return r.innerHTML = n, r.className = "instant-devtool-toggler", Object.assign(r.style, Object.assign(Object.assign({
    // pos
    position: "fixed"
  }, aa(t.position)), {
    height: "32px",
    width: "32px",
    // layout
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    zIndex: "9010",
    // look
    padding: "0",
    margin: "0",
    border: "none",
    cursor: "pointer"
  })), r.addEventListener("click", e), { element: r };
}
function aa(t) {
  switch (t) {
    case "bottom-left":
      return { bottom: "24px", left: "24px" };
    case "bottom-right":
      return { bottom: "24px", right: "24px" };
    case "top-right":
      return { top: "24px", right: "24px" };
    case "top-left":
      return { top: "24px", left: "24px" };
  }
}
function ca(t) {
  switch (t) {
    case "bottom-left":
      return { bottom: "24px", right: "24px", left: "60px", top: "72px" };
    case "bottom-right":
      return { bottom: "24px", left: "24px", right: "60px", top: "72px" };
    case "top-right":
      return { top: "24px", left: "24px", right: "60px", bottom: "72px" };
    case "top-left":
      return { top: "24px", right: "24px", left: "60px", bottom: "72px" };
  }
}
function da(t) {
  const e = document.createElement("div");
  Object.assign(e.style, Object.assign(Object.assign({ position: "fixed" }, ca(t.position)), { display: "block", borderRadius: "4px", border: "1px #ccc solid", boxShadow: "0px 0px 8px #00000044", backgroundColor: "#eee", zIndex: "999990" })), e.style.display = "none", e.className = "instant-devtool-container";
  function n() {
    return e.style.display !== "none";
  }
  return { element: e, isVisible: n };
}
const fa = {
  apiURI: "https://api.instantdb.com",
  websocketURI: "wss://api.instantdb.com/runtime/session"
};
function la() {
  var t;
  return globalThis.__instantDbSchemaHashStore = (t = globalThis.__instantDbSchemaHashStore) !== null && t !== void 0 ? t : /* @__PURE__ */ new WeakMap(), globalThis.__instantDbSchemaHashStore;
}
function ha() {
  var t;
  return globalThis.__instantDbStore = (t = globalThis.__instantDbStore) !== null && t !== void 0 ? t : {}, globalThis.__instantDbStore;
}
function Jt(t) {
  const e = t.__adminToken;
  return t.appId + "_" + (t.websocketURI || "default_ws_uri") + "_" + (t.apiURI || "default_api_uri") + "_" + (e || "client_only") + "_" + t.useDateObjects;
}
const Zt = ha(), mr = la();
class pa {
  constructor(e) {
    this.db = e, this.sendMagicCode = (n) => this.db.sendMagicCode(n), this.signInWithMagicCode = (n) => this.db.signInWithMagicCode(n), this.signInWithToken = (n) => this.db.signInWithCustomToken(n), this.signInAsGuest = () => this.db.signInAsGuest(), this.createAuthorizationURL = (n) => this.db.createAuthorizationURL(n), this.signInWithIdToken = (n) => this.db.signInWithIdToken(n), this.exchangeOAuthCode = (n) => this.db.exchangeCodeForToken(n), this.issuerURI = () => this.db.issuerURI(), this.signOut = (n = { invalidateToken: !0 }) => this.db.signOut(n);
  }
}
class ya {
  constructor(e) {
    this.db = e, this.uploadFile = (n, r, i = {}) => this.db.uploadFile(n, r, i), this.delete = (n) => this.db.deleteFile(n), this.upload = (n, r) => this.db.upload(n, r), this.put = this.upload, this.getDownloadUrl = (n) => this.db.getDownloadUrl(n);
  }
}
function ba(t) {
  return JSON.parse(JSON.stringify(t));
}
class _a {
  constructor(e) {
    this.tx = ln(), this._reactor = e, this.auth = new pa(this._reactor), this.storage = new ya(this._reactor);
  }
  /**
   * Use this to write data! You can create, update, delete, and link objects
   *
   * @see https://instantdb.com/docs/instaml
   *
   * @example
   *   // Create a new object in the `goals` namespace
   *   const goalId = id();
   *   db.transact(db.tx.goals[goalId].update({title: "Get fit"}))
   *
   *   // Update the title
   *   db.transact(db.tx.goals[goalId].update({title: "Get super fit"}))
   *
   *   // Delete it
   *   db.transact(db.tx.goals[goalId].delete())
   *
   *   // Or create an association:
   *   todoId = id();
   *   db.transact([
   *    db.tx.todos[todoId].update({ title: 'Go on a run' }),
   *    db.tx.goals[goalId].link({todos: todoId}),
   *  ])
   */
  transact(e) {
    return this._reactor.pushTx(e);
  }
  getLocalId(e) {
    return this._reactor.getLocalId(e);
  }
  /**
   * Use this to query your data!
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *  // listen to all goals
   *  db.subscribeQuery({ goals: {} }, (resp) => {
   *    console.log(resp.data.goals)
   *  })
   *
   *  // goals where the title is "Get Fit"
   *  db.subscribeQuery(
   *    { goals: { $: { where: { title: "Get Fit" } } } },
   *    (resp) => {
   *      console.log(resp.data.goals)
   *    }
   *  )
   *
   *  // all goals, _alongside_ their todos
   *  db.subscribeQuery({ goals: { todos: {} } }, (resp) => {
   *    console.log(resp.data.goals)
   *  });
   */
  subscribeQuery(e, n, r) {
    return this._reactor.subscribeQuery(e, n, r);
  }
  /**
   * Listen for the logged in state. This is useful
   * for deciding when to show a login screen.
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *   const unsub = db.subscribeAuth((auth) => {
   *     if (auth.user) {
   *     console.log('logged in as', auth.user.email)
   *    } else {
   *      console.log('logged out')
   *    }
   *  })
   */
  subscribeAuth(e) {
    return this._reactor.subscribeAuth(e);
  }
  /**
   * One time query for the logged in state. This is useful
   * for scenarios where you want to know the current auth
   * state without subscribing to changes.
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *   const user = await db.getAuth();
   *   console.log('logged in as', user.email)
   */
  getAuth() {
    return this._reactor.getAuth();
  }
  /**
   * Listen for connection status changes to Instant. This is useful
   * for building things like connectivity indicators
   *
   * @see https://www.instantdb.com/docs/patterns#connection-status
   * @example
   *   const unsub = db.subscribeConnectionStatus((status) => {
   *     const connectionState =
   *       status === 'connecting' || status === 'opened'
   *         ? 'authenticating'
   *       : status === 'authenticated'
   *         ? 'connected'
   *       : status === 'closed'
   *         ? 'closed'
   *       : status === 'errored'
   *         ? 'errored'
   *       : 'unexpected state';
   *
   *     console.log('Connection status:', connectionState);
   *   });
   */
  subscribeConnectionStatus(e) {
    return this._reactor.subscribeConnectionStatus(e);
  }
  /**
   * Join a room to publish and subscribe to topics and presence.
   *
   * @see https://instantdb.com/docs/presence-and-topics
   * @example
   * // init
   * const db = init();
   * const room = db.joinRoom(roomType, roomId);
   * // usage
   * const unsubscribeTopic = room.subscribeTopic("foo", console.log);
   * const unsubscribePresence = room.subscribePresence({}, console.log);
   * room.publishTopic("hello", { message: "hello world!" });
   * room.publishPresence({ name: "joe" });
   * // later
   * unsubscribePresence();
   * unsubscribeTopic();
   * room.leaveRoom();
   */
  joinRoom(e = "_defaultRoomType", n = "_defaultRoomId", r) {
    return {
      leaveRoom: this._reactor.joinRoom(n, r == null ? void 0 : r.initialPresence),
      subscribeTopic: (s, o) => this._reactor.subscribeTopic(n, s, o),
      subscribePresence: (s, o) => this._reactor.subscribePresence(e, n, s, o),
      publishTopic: (s, o) => this._reactor.publishTopic({ roomType: e, roomId: n, topic: s, data: o }),
      publishPresence: (s) => this._reactor.publishPresence(e, n, s),
      getPresence: (s) => this._reactor.getPresence(e, n, s)
    };
  }
  shutdown() {
    delete Zt[Jt(this._reactor.config)], this._reactor.shutdown();
  }
  /**
   * Use this for one-off queries.
   * Returns local data if available, otherwise fetches from the server.
   * Because we want to avoid stale data, this method will throw an error
   * if the user is offline or there is no active connection to the server.
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *
   *  const resp = await db.queryOnce({ goals: {} });
   *  console.log(resp.data.goals)
   */
  queryOnce(e, n) {
    return this._reactor.queryOnce(e, n);
  }
  /**
   * @deprecated This is an experimental function that is not yet ready for production use.
   * Use this function to sync an entire namespace.
   * It has many limitations that will be removed in the future:
   * 1. Must be used with an admin token
   * 2. Does not support permissions
   * 3. Does not support where clauses
   * 4. Does not support links
   * It also does not support multiple top-level namespaces. For example,
   *  {posts: {}, users: {}} is invalid. Only `posts` or `users` is allowed, but not both.
   */
  _syncTableExperimental(e, n) {
    return this._reactor.subscribeTable(e, n);
  }
}
function wr(t) {
  if (!t)
    return "0";
  const e = mr.get(t);
  if (e)
    return e;
  const n = N(t);
  return mr.set(t, n), n;
}
function ga(t, e) {
  return wr(t._reactor.config.schema) !== wr(e);
}
function Ta(t, e, n, r, i) {
  var s;
  const o = Object.assign(Object.assign({}, t), { useDateObjects: (s = t.useDateObjects) !== null && s !== void 0 ? s : !1 }), u = Zt[Jt(o)];
  if (u)
    return ga(u, o.schema) && u._reactor.updateSchema(o.schema), u;
  const a = new ra(Object.assign(Object.assign(Object.assign({}, fa), o), { cardinalityInference: !!o.schema }), e || ti, n || ni, Object.assign(Object.assign({}, r || {}), { "@instantdb/core": oi }), i), d = new _a(a);
  return Zt[Jt(o)] = d, ma(o.appId, o.devtool), d;
}
function ma(t, e) {
  if (typeof window > "u" || typeof window.location > "u" || typeof document > "u" || typeof e == "boolean" && !e)
    return;
  const n = Object.assign({ position: "bottom-right", allowedHosts: ["localhost"] }, typeof e == "object" ? e : {});
  n.allowedHosts.includes(window.location.hostname) && ia(t, n);
}
const wa = {
  isLoading: !0,
  data: void 0,
  pageInfo: void 0,
  error: void 0
};
function vr(t) {
  return {
    isLoading: !t,
    data: void 0,
    pageInfo: void 0,
    error: void 0,
    ...t || {}
  };
}
function va(t, e, n) {
  e && n && "ruleParams" in n && (e = { $$ruleParams: n.ruleParams, ...e });
  const r = e ? ba(e) : null, i = N(r), s = ze(
    vr(t._reactor.getPreviousResult(r))
  ), o = de(
    (a) => (s.current = vr(
      t._reactor.getPreviousResult(r)
    ), r ? t.subscribeQuery(r, (c) => {
      s.current = {
        isLoading: !c,
        // @ts-expect-error: ts thinks this will always be overwritten
        data: void 0,
        // @ts-expect-error: ts thinks this will always be overwritten
        pageInfo: void 0,
        // @ts-expect-error: ts thinks this will always be overwritten
        error: void 0,
        ...c
      }, a();
    }) : () => {
    }),
    // Build a new subscribe function if the query changes
    [i]
  );
  return { state: Mt(
    o,
    () => s.current,
    () => wa
  ), query: r };
}
function Sa() {
  const t = ze(null);
  ge(() => {
    n();
  }, []);
  function e(r, i) {
    n(), t.current = setTimeout(i, r);
  }
  function n() {
    t.current && clearTimeout(t.current);
  }
  return { set: e, clear: n };
}
const Oa = 1e3;
function Ea(t, e, n) {
  const r = ze(n);
  r.current = n, ge(() => t.core._reactor.subscribeTopic(
    t.id,
    e,
    (s, o) => {
      r.current(s, o);
    }
  ), [t.id, e]);
}
function Aa(t, e) {
  return ge(() => t.core._reactor.joinRoom(t.id), [t.id]), de(
    (r) => {
      t.core._reactor.publishTopic({
        roomType: t.type,
        roomId: t.id,
        topic: e,
        data: r
      });
    },
    [t.id, e]
  );
}
function ja(t, e = {}) {
  var o, u;
  const [n, r] = Or(() => t.core._reactor.getPresence(t.type, t.id, e) ?? {
    peers: {},
    isLoading: !0
  });
  ge(() => t.core._reactor.subscribePresence(
    t.type,
    t.id,
    e,
    (d) => {
      r(d);
    }
  ), [t.id, e.user, (o = e.peers) == null ? void 0 : o.join(), (u = e.keys) == null ? void 0 : u.join()]);
  const i = de(
    (a) => {
      t.core._reactor.publishPresence(t.type, t.id, a);
    },
    [t.type, t.id]
  );
  return Rt(() => ({
    ...n,
    publishPresence: i
  }), [n, i]);
}
function ka(t, e, n) {
  ge(() => t.core._reactor.joinRoom(t.id, e), [t.id]), ge(() => t.core._reactor.publishPresence(t.type, t.id, e), [t.type, t.id, n ?? JSON.stringify(e)]);
}
function Ca(t, e, n = {}) {
  const r = Sa(), i = ye.usePresence(t, {
    keys: [e]
  }), s = Rt(() => {
    const c = t._core._reactor.getPresence(
      t.type,
      t.id
    );
    return n != null && n.writeOnly ? [] : Object.values((c == null ? void 0 : c.peers) ?? {}).filter(
      (f) => f[e] === !0
    );
  }, [n == null ? void 0 : n.writeOnly, i]), o = de(
    (c) => {
      t.core._reactor.publishPresence(t.type, t.id, {
        [e]: c
      }), c && ((n == null ? void 0 : n.timeout) === null || (n == null ? void 0 : n.timeout) === 0 || r.set((n == null ? void 0 : n.timeout) ?? Oa, () => {
        t.core._reactor.publishPresence(t.type, t.id, {
          [e]: null
        });
      }));
    },
    [t.type, t.id, e, n == null ? void 0 : n.timeout, r]
  ), u = de(
    (c) => {
      const l = !((n == null ? void 0 : n.stopOnEnter) && c.key === "Enter");
      o(l);
    },
    [n.stopOnEnter, o]
  ), a = de(() => {
    o(!1);
  }, [o]), d = Rt(() => ({ onKeyDown: u, onBlur: a }), [u, a]);
  return {
    active: s,
    setActive: o,
    inputProps: d
  };
}
const ye = {
  useTopicEffect: Ea,
  usePublishTopic: Aa,
  usePresence: ja,
  useSyncPresence: ka,
  useTypingIndicator: Ca
};
class Pa {
  constructor(e, n, r) {
    this.useTopicEffect = (i, s) => {
      ye.useTopicEffect(this, i, s);
    }, this.usePublishTopic = (i) => ye.usePublishTopic(this, i), this.usePresence = (i = {}) => ye.usePresence(this, i), this.useSyncPresence = (i, s) => ye.useSyncPresence(this, i, s), this.useTypingIndicator = (i, s = {}) => ye.useTypingIndicator(this, i, s), this.core = e, this._core = this.core, this.type = n, this.id = r;
  }
}
const Ia = {
  isLoading: !0,
  user: void 0,
  error: void 0
};
class Ra {
  constructor(e, n) {
    this.tx = ln(), this.getLocalId = (r) => this.core.getLocalId(r), this.useLocalId = (r) => {
      const [i, s] = Or(null);
      return ge(() => {
        (async () => {
          const u = await this.getLocalId(r);
          s(u);
        })();
      }, [r]), i;
    }, this.rooms = ye, this.transact = (r) => this.core.transact(r), this.useQuery = (r, i) => va(this.core, r, i).state, this.useAuth = () => {
      const r = ze(
        this.core._reactor._currentUserCached
      ), i = de((o) => this.core.subscribeAuth((a) => {
        r.current = { isLoading: !1, ...a }, o();
      }), []);
      return Mt(
        i,
        () => r.current,
        () => Ia
      );
    }, this.useUser = () => {
      const { user: r } = this.useAuth();
      if (!r)
        throw new je(
          "useUser must be used within an auth-protected route"
        );
      return r;
    }, this.useConnectionStatus = () => {
      const r = ze(
        this.core._reactor.status
      ), i = de((o) => this.core.subscribeConnectionStatus((a) => {
        a !== r.current && (r.current = a, o());
      }), []);
      return Mt(
        i,
        () => r.current,
        // For SSR, always return 'connecting' as the initial state
        () => "connecting"
      );
    }, this.queryOnce = (r, i) => this.core.queryOnce(r, i), this.SignedIn = ({ children: r }) => {
      const i = this.useAuth();
      return i.isLoading || i.error || !i.user ? null : /* @__PURE__ */ et.jsx(et.Fragment, { children: r });
    }, this.SignedOut = ({ children: r }) => {
      const i = this.useAuth();
      return i.isLoading || i.error || i.user ? null : /* @__PURE__ */ et.jsx(et.Fragment, { children: r });
    }, this.core = Ta(
      e,
      // @ts-expect-error because TS can't resolve subclass statics
      this.constructor.Storage,
      // @ts-expect-error because TS can't resolve subclass statics
      this.constructor.NetworkListener,
      n,
      // @ts-expect-error because TS can't resolve subclass statics
      this.constructor.EventSourceImpl
    ), this._core = this.core, this.auth = this.core.auth, this.storage = this.core.storage;
  }
  /**
   * Obtain a handle to a room, which allows you to listen to topics and presence data
   *
   * If you don't provide a `type` or `id`, Instant will default to `_defaultRoomType` and `_defaultRoomId`
   * as the room type and id, respectively.
   *
   * @see https://instantdb.com/docs/presence-and-topics
   *
   * @example
   *  const room = db.room('chat', roomId);
   *  const { peers } = db.rooms.usePresence(room);
   */
  room(e = "_defaultRoomType", n = "_defaultRoomId") {
    return new Pa(this.core, e, n);
  }
  /**
   * One time query for the logged in state. This is useful
   * for scenarios where you want to know the current auth
   * state without subscribing to changes.
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *   const user = await db.getAuth();
   *   console.log('logged in as', user.email)
   */
  getAuth() {
    return this.core.getAuth();
  }
}
export {
  Ra as InstantReactAbstractDatabase
};
