import { o as NEON_AUTH_SESSION_VERIFIER_PARAM_NAME } from "../adapter-core-ChIlSbGg.mjs";
import { t as BetterAuthReactAdapter } from "../better-auth-react-adapter-C3_WRaIy.mjs";
import { t as createAuthClient$1 } from "../neon-auth-sSiNq4zM.mjs";
import { parseCookies, parseSetCookieHeader } from "better-auth/cookies";
import { NextRequest, NextResponse } from "next/server";
import { cookies, headers } from "next/headers";

//#region src/next/errors.ts
const ERRORS = { MISSING_AUTH_BASE_URL: "Missing environment variable: NEON_AUTH_BASE_URL. \n You must provide the auth url of your Neon Auth instance in environment variables" };

//#endregion
//#region src/next/constants.ts
const NEON_AUTH_COOKIE_PREFIX = "__Secure-neon-auth";
const NEON_AUTH_SESSION_COOKIE_NAME = `${NEON_AUTH_COOKIE_PREFIX}.session_token`;
const NEON_AUTH_SESSION_CHALLENGE_COOKIE_NAME = `${NEON_AUTH_COOKIE_PREFIX}.session_challange`;
const NEON_AUTH_HEADER_MIDDLEWARE_NAME = "X-Neon-Auth-Next-Middleware";

//#endregion
//#region src/next/auth/cookies.ts
/**
* Extract the Neon Auth cookies from the request headers that starts with the NEON_AUTH_COOKIE_PREFIX.
* 
* @param headers - The request headers.
* @returns The cookie string with all Neon Auth cookies.
*/
function extractRequestCookies(headers$1) {
	const cookieHeader = headers$1.get("cookie");
	if (!cookieHeader) return "";
	const parsedCookies = parseCookies(cookieHeader);
	const result = [];
	for (const [name, value] of parsedCookies.entries()) if (name.startsWith(NEON_AUTH_COOKIE_PREFIX)) result.push({
		name,
		value
	});
	return result.map((cookie) => cookie.name + "=" + cookie.value).join("; ");
}
/**
* Extract the Neon Auth cookies from the response headers that starts with the NEON_AUTH_COOKIE_PREFIX.
* 
* @param headers - The response headers.
* @returns The cookies that starts with the NEON_AUTH_COOKIE_PREFIX.
*/
const extractResponseCookies = (headers$1) => {
	const cookieHeader = headers$1.get("set-cookie");
	if (!cookieHeader) return [];
	return cookieHeader.split(", ").map((c) => c.trim());
};
/**
* 
* Parses the `set-cookie` header from Neon Auth response into the list of ResponseCookies,
*  compatible with NextCookies.
* 
* @param cookies - The `set-cookie` header from Neon Auth response.
* @returns The list of ResponseCookies.
*/
const parseSetCookies = (cookies$1) => {
	const parsedCookies = parseSetCookieHeader(cookies$1);
	const responseCookies = [];
	for (const entry of parsedCookies.entries()) {
		const [name, parsedCookie] = entry;
		responseCookies.push({
			name,
			value: decodeURIComponent(parsedCookie.value),
			path: parsedCookie.path,
			maxAge: parsedCookie["max-age"] ?? parsedCookie.maxAge,
			httpOnly: parsedCookie.httponly ?? true,
			secure: parsedCookie.secure ?? true,
			sameSite: parsedCookie.samesite ?? "none",
			partitioned: parsedCookie.partitioned
		});
	}
	return responseCookies;
};

//#endregion
//#region src/next/handler/request.ts
const PROXY_HEADERS = [
	"user-agent",
	"authorization",
	"referer",
	"content-type"
];
const handleAuthRequest = async (baseUrl, request, path) => {
	const headers$1 = prepareRequestHeaders(request);
	const body = await parseRequestBody(request);
	try {
		const upstreamURL = getUpstreamURL(baseUrl, path, { originalUrl: new URL(request.url) });
		return await fetch(upstreamURL.toString(), {
			method: request.method,
			headers: headers$1,
			body
		});
	} catch (error) {
		const message = error instanceof Error ? error.message : "Internal Server Error";
		console.error(`[AuthError] ${message}`, error);
		return new Response(`[AuthError] ${message}`, { status: 500 });
	}
};
const getUpstreamURL = (baseUrl, path, { originalUrl }) => {
	const url = new URL(`${baseUrl}/${path}`);
	if (originalUrl) {
		url.search = originalUrl.search;
		return url;
	}
	return url;
};
const prepareRequestHeaders = (request) => {
	const headers$1 = new Headers();
	for (const header of PROXY_HEADERS) if (request.headers.get(header)) headers$1.set(header, request.headers.get(header));
	headers$1.set("Origin", getOrigin(request));
	headers$1.set("Cookie", extractRequestCookies(request.headers));
	headers$1.set(NEON_AUTH_HEADER_MIDDLEWARE_NAME, "true");
	return headers$1;
};
const getOrigin = (request) => {
	return request.headers.get("origin") || request.headers.get("referer")?.split("/").slice(0, 3).join("/") || new URL(request.url).origin;
};
const parseRequestBody = async (request) => {
	if (request.body) return request.text();
};

//#endregion
//#region src/next/handler/response.ts
const RESPONSE_HEADERS_ALLOWLIST = [
	"content-type",
	"content-length",
	"content-encoding",
	"transfer-encoding",
	"connection",
	"date",
	"set-cookie",
	"set-auth-jwt",
	"set-auth-token",
	"x-neon-ret-request-id"
];
const handleAuthResponse = async (response) => {
	return new Response(response.body, {
		status: response.status,
		statusText: response.statusText,
		headers: prepareResponseHeaders(response)
	});
};
const prepareResponseHeaders = (response) => {
	const headers$1 = new Headers();
	for (const header of RESPONSE_HEADERS_ALLOWLIST) {
		const value = response.headers.get(header);
		if (value) headers$1.set(header, value);
	}
	return headers$1;
};

//#endregion
//#region src/next/handler/index.ts
/**
* 
* An API route handler to handle the auth requests from the client and proxy them to the Neon Auth.
* 
* @returns A Next.js API handler functions those can be used in a Next.js route.
*
* @example
* 
* Mount the `authApiHandler` to an API route. Create a route file inside `/api/auth/[...all]/route.ts` directory. 
*  And add the following code:
* 
* ```ts 
* 
* import { authApiHandler } from '@neondatabase/auth/next';
* 
* export const { GET, POST } = authApiHandler();
* ```
* 
*/
function authApiHandler() {
	const baseURL = process.env.NEON_AUTH_BASE_URL;
	if (!baseURL) throw new Error(ERRORS.MISSING_AUTH_BASE_URL);
	const handler = async (request, { params }) => {
		return await handleAuthResponse(await handleAuthRequest(baseURL, request, (await params).path.join("/")));
	};
	return {
		GET: handler,
		POST: handler,
		PUT: handler,
		DELETE: handler,
		PATCH: handler
	};
}

//#endregion
//#region src/next/middleware/oauth.ts
const needsSessionVerification = (request) => {
	const hasVerifier = request.nextUrl.searchParams.has(NEON_AUTH_SESSION_VERIFIER_PARAM_NAME);
	const hasChallenge = request.cookies.get(NEON_AUTH_SESSION_CHALLENGE_COOKIE_NAME);
	return hasVerifier && hasChallenge;
};
const exchangeOAuthToken = async (request, baseUrl) => {
	const url = request.nextUrl;
	const verifier = url.searchParams.get(NEON_AUTH_SESSION_VERIFIER_PARAM_NAME);
	const challenge = request.cookies.get(NEON_AUTH_SESSION_CHALLENGE_COOKIE_NAME);
	if (!verifier || !challenge) return null;
	const response = await handleAuthResponse(await handleAuthRequest(baseUrl, new Request(request.url, {
		method: "GET",
		headers: request.headers
	}), "get-session"));
	if (response.ok) {
		const headers$1 = new Headers();
		const cookies$1 = extractResponseCookies(response.headers);
		for (const cookie of cookies$1) headers$1.append("Set-Cookie", cookie);
		url.searchParams.delete(NEON_AUTH_SESSION_VERIFIER_PARAM_NAME);
		return NextResponse.redirect(url, { headers: headers$1 });
	}
	return null;
};

//#endregion
//#region src/next/env-variables.ts
const NEON_AUTH_BASE_URL = process.env.NEON_AUTH_BASE_URL;

//#endregion
//#region src/next/auth/session.ts
/**
* A utility function to be used in react server components fetch the session details from the Neon Auth API, if session token is available in cookie.
*
* @returns - `{ session: Session, user: User }` | `{ session: null, user: null}`.
*
* @example
* ```ts
* import { neonAuth } from "@neondatabase/auth/next"
*
* const { session, user } = await neonAuth()
* ```
*/
const neonAuth = async () => {
	return await fetchSession();
};
/**
* A utility function to fetch the session details from the Neon Auth API, if session token is available in cookie.
*
* @returns - `{ session: Session, user: User }` | `{ session: null, user: null}`.
*/
const fetchSession = async () => {
	const baseUrl = NEON_AUTH_BASE_URL;
	const requestHeaders = await headers();
	const upstreamURL = getUpstreamURL(baseUrl, "get-session", { originalUrl: new URL("get-session", baseUrl) });
	const response = await fetch(upstreamURL.toString(), {
		method: "GET",
		headers: { Cookie: extractRequestCookies(requestHeaders) }
	});
	const body = await response.json();
	const cookieHeader = response.headers.get("set-cookie");
	if (cookieHeader) {
		const cookieStore = await cookies();
		parseSetCookies(cookieHeader).map((cookie) => {
			cookieStore.set(cookie.name, cookie.value, cookie);
		});
	}
	if (!response.ok || body === null) return {
		session: null,
		user: null
	};
	return {
		session: body.session,
		user: body.user
	};
};

//#endregion
//#region src/next/middleware/index.ts
const SKIP_ROUTES = [
	"/api/auth",
	"/auth/callback",
	"/auth/sign-in",
	"/auth/sign-up",
	"/auth/magic-link",
	"/auth/email-otp",
	"/auth/forgot-password"
];
/**
* A Next.js middleware to protect routes from unauthenticated requests and refresh the session if required.
*
* @param loginUrl - The URL to redirect to when the user is not authenticated.
* @returns A middleware function that can be used in the Next.js app.
*
* @example
* ```ts
* import { neonAuthMiddleware } from "@neondatabase/auth/next"
*
* export default neonAuthMiddleware({
*   loginUrl: '/auth/sign-in',
* });
* ```
*/
function neonAuthMiddleware({ loginUrl = "/auth/sign-in" }) {
	const baseUrl = NEON_AUTH_BASE_URL;
	if (!baseUrl) throw new Error(ERRORS.MISSING_AUTH_BASE_URL);
	return async (request) => {
		const { pathname } = request.nextUrl;
		if (pathname.startsWith(loginUrl)) return NextResponse.next();
		if (needsSessionVerification(request)) {
			const response = await exchangeOAuthToken(request, baseUrl);
			if (response !== null) return response;
		}
		if (SKIP_ROUTES.some((route) => pathname.startsWith(route))) return NextResponse.next();
		if ((await fetchSession()).session === null) return NextResponse.redirect(new URL(loginUrl, request.url));
		const reqHeaders = new Headers(request.headers);
		reqHeaders.set(NEON_AUTH_HEADER_MIDDLEWARE_NAME, "true");
		return NextResponse.next({ request: { headers: reqHeaders } });
	};
}

//#endregion
//#region src/next/index.ts
function createAuthClient() {
	return createAuthClient$1(void 0, { adapter: BetterAuthReactAdapter() });
}

//#endregion
export { authApiHandler, createAuthClient, neonAuth, neonAuthMiddleware };